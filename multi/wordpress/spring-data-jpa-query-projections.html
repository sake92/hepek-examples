<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Spring Data JPA: Query Projections</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Spring Data JPA: Query Projections</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Projection is one of the first things you&#8217;re probably thinking about when implementing a query with <a href="https://thorben-janssen.com/what-is-spring-data-jpa-and-why-should-you-use-it/">Spring Data JPA</a>. This is because projection defines the entity attributes and the database columns returned by your query. So, selecting the right columns is important for your business logic. At the same time, projection is also crucial for the <a href="https://thorben-janssen.com/tips-to-boost-your-hibernate-performance/">performance of your application</a> and the maintainability of your code. In addition, you need to choose a projection that keeps the overhead as low as possible and provides the data in an easy to use structure. </p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Types_of_Projections_Supported_by_Spring_Data_JPA"><span class="toc_number toc_depth_1">1</span> Types of Projections Supported by Spring Data JPA</a></li><li><a href="#Scalar_Projections"><span class="toc_number toc_depth_1">2</span> Scalar Projections</a></li><li><a href="#DTO_Projections"><span class="toc_number toc_depth_1">3</span> DTO Projections</a><ul><li><a href="#JPA8217s_DTOs"><span class="toc_number toc_depth_2">3.1</span> JPA&#8217;s DTOs</a></li><li><a href="#Spring_Data8217s_Simplified_DTOs"><span class="toc_number toc_depth_2">3.2</span> Spring Data&#8217;s Simplified DTOs</a></li><li><a href="#DTOs_as_Interfaces"><span class="toc_number toc_depth_2">3.3</span> DTOs as Interfaces</a><ul><li><a href="#Mapping_Nested_Associations"><span class="toc_number toc_depth_3">3.3.1</span> Mapping Nested Associations</a></li><li><a href="#Using_Spring8217s_Expression_Language"><span class="toc_number toc_depth_3">3.3.2</span> Using Spring&#8217;s Expression Language</a></li></ul></li></ul></li><li><a href="#Entity_Projections"><span class="toc_number toc_depth_1">4</span> Entity Projections</a></li><li><a href="#Dynamic_Projections"><span class="toc_number toc_depth_1">5</span> Dynamic Projections</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">6</span> Conclusion</a></li></ul></div>
<h2><span id="Types_of_Projections_Supported_by_Spring_Data_JPA">Types of Projections Supported by Spring Data JPA</span></h2>



<p>Based on <a href="https://thorben-janssen.com/projections-with-jpa-and-hibernate/">JPA&#8217;s query capabilities</a>, Spring Data JPA gives you several options for defining your use case&#8217;s perfect projection. You can:</p>



<ul><li>Use a scalar projection that consists of one or more database columns that are returned as an <em>Object[]</em>. This projection provides great performance for the read operation but it is used rarely. This is because DTO projections offer&nbsp;the same benefits while being much easier to use.</li><li>Use a DTO projection, which selects a custom set of database columns. It uses them to call a constructor and returns one or more unmanaged objects. This is a great projection if you don&#8217;t need to change the selected data.</li><li>Use an entity projection that selects all database columns mapped by an entity class and returns them as a managed object. Entities are the recommended projection if you want to change the retrieved information.</li></ul>



<p>You can use all three projections with Spring Data JPA&#8217;s <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derived</a> and <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">custom queries</a>. Spring will provide you with the required boilerplate code. In addition, it also makes DTO projections a lot easier to use and allows you to define the projection returned by a repository method dynamically.</p>



<h2><span id="Scalar_Projections">Scalar Projections</span></h2>



<p>Scalar projections allow you to select entity attributes that you need for your business logic and exclude the rest. That makes this projection a great fit for all read operations if the results aren&#8217;t returned as <em>Object[]</em>s. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {

	@Query(&quot;SELECT b.id, b.title FROM Book b&quot;)
	List&lt;Object[]&gt; getIdAndTitle();	
}</pre>



<p>A query result stored in an <em>Object[]</em> is hard to use. You need to remember at which position you selected a particular entity attribute. Also, you need to cast the element to the correct type. The good news is that you can avoid all of that and define a use-case-specific projection by using a DTO projection. </p>



<h2><span id="DTO_Projections">DTO Projections</span></h2>



<p>When using a DTO projection, you tell your persistence provider to map each record of your query result to an unmanaged object. As shown in a <a href="https://thorben-janssen.com/entities-dtos-use-projection/">previous article</a>, this performs much better than entities if you don&#8217;t need to change the selected data. And, in contrast to scalar value projections, they are also very easy to use. This is because the DTO objects are named and strongly typed.</p>



<h3><span id="JPA8217s_DTOs">JPA&#8217;s DTOs</span></h3>



<p>The goal of a DTO class is to provide an efficient and strongly typed representation of the data returned by your query. To achieve that, a DTO class typically only defines a set of attributes, getter and setter methods for each of them, and a constructor that sets all attributes.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public class AuthorSummaryDTO {
	
	private String firstName;
	private String lastName;
	
	public AuthorSummaryDTO(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
}</pre>



<p>To use this class as a projection with plain JPA, you need to use a <a href="https://thorben-janssen.com/jpql/">constructor expression in your query</a>. It describes a call of the constructor. It starts with the keyword <em>new</em>, followed by the DTO class&#8217;s fully-qualified class name and a list of constructor parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {

	@Query(&quot;SELECT new com.thorben.janssen.spring.jpa.projections.dto.AuthorSummaryDTO(a.firstName, a.lastName) FROM Author a WHERE a.firstName = :firstName&quot;)
	List&lt;AuthorSummaryDTO&gt; findByFirstName(String firstName);
}</pre>



<p>As you can see in the code snippet, you can use this approach in <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">Spring Data JPA&#8217;s @Query annotation</a>. Your persistence provider then executes a query that selects the columns mapped by the referenced entity attributes and executes the described constructor call.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">2020-07-12 20:42:09.875 DEBUG 61380 --- [           main] org.hibernate.SQL                        : select author0_.first_name as col_0_0_, author0_.last_name as col_1_0_ from author author0_ where author0_.first_name=?</pre>



<p>In addition to this, Spring provides a few other options to select a DTO projection.</p>



<h3><span id="Spring_Data8217s_Simplified_DTOs">Spring Data&#8217;s Simplified DTOs</span></h3>



<p>You can use DTO projections in a <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derived query</a> without a constructor expression. As long as the DTO class has only one constructor and its parameter names match your entity class&#8217;s attribute names, Spring generates a query with the required constructor expression.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {

	List&lt;AuthorSummaryDTO&gt; findByFirstName(String firstName);
}</pre>



<p>This makes the query&#8217;s definition easier and still provides you with the performance benefits of a query that only selects the required database columns.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">2020-07-12 20:43:23.316 DEBUG 61200 --- [           main] org.hibernate.SQL                        : select author0_.first_name as col_0_0_, author0_.last_name as col_1_0_ from author author0_ where author0_.first_name=?</pre>



<h3><span id="DTOs_as_Interfaces">DTOs as Interfaces</span></h3>



<p>Instead of defining a class with an all arguments constructor, you can also use an interface as your DTO projection. As long as your interface only defines getter methods for basic attributes, this is identical to the projection I showed you before.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorView {
	String getFirstName();
	String getLastName();
}</pre>



<p>To clarify, for each attribute that you want to use in your projection, your interface needs to provide a getter method. In addition, the name of that method has to be identical to that of a getter method defined on the entity class used in your query. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {
	
	AuthorView  findViewByFirstName(String firstName);
}</pre>



<p>In this example, the <em>AuthorView </em>interface and the <em>Author </em>entity define a <em>getFirstName()</em> and a <em>getLastName()</em> method. When you use the <em>AuthorView </em>interface as a return type in the <em>AuthorRepository</em>, Spring Data JPA generates a class that implements the interface. </p>



<p>This makes this form of a DTO projection very comfortable to use. And as you can see in the code snippet, the generated SQL statement only selects the columns mapped by the interface.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">2020-07-12 20:57:35.590 DEBUG 38520 --- [           main] org.hibernate.SQL                        : select author0_.first_name as col_0_0_, author0_.last_name as col_1_0_ from author author0_ where author0_.first_name=?</pre>



<p>That changes, if your interface maps associations to other entities or uses Spring&#8217;s Expression Language.</p>



<h4><span id="Mapping_Nested_Associations">Mapping Nested Associations</span></h4>



<p>To be able to include associations to other entities in your projection, Spring Data JPA needs to use a different approach. It then selects the underlying entities and performs a programmatic mapping.</p>



<p>In the following example, the <em>Author</em> entity defines a <em>getBooks() </em>method that returns a <em>List </em>of all <em>Book</em>s written by an author. You can tell Spring Data to map that <em>List </em>to a <em>List </em>of <em>BookView</em> objects by adding the method <em>List&lt;BookView&gt; getBooks()</em> to the <em>AuthorView</em> interface.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorView {

	String getFirstName();
	String getLastName();
	
	List&lt;BookView&gt; getBooks();
	
	interface BookView {
		
		String getTitle();
	}
}</pre>



<p>When you do that, Spring Data JPA will get the <em>Author </em>entity and trigger another query for each <em>Author </em>to fetch the associated <em>Book </em>entities. This creates an <a href="https://thorben-janssen.com/free-n1_select_course/">n+1 select issue</a>, which can cause severe performance issues. You can avoid that by providing a <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">custom query</a> using a <a href="https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/">JOIN FETCH clause</a>.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">2020-07-12 21:20:00.471 DEBUG 54180 --- [           main] org.hibernate.SQL                        : select author0_.id as id1_0_, author0_.first_name as first_na2_0_, author0_.last_name as last_nam3_0_, author0_.version as version4_0_ from author author0_ where author0_.first_name=?
2020-07-12 21:20:00.503 DEBUG 54180 --- [           main] org.hibernate.SQL                        : select books0_.author_id as author_i4_1_0_, books0_.id as id1_1_0_, books0_.id as id1_1_1_, books0_.author_id as author_i4_1_1_, books0_.title as title2_1_1_, books0_.version as version3_1_1_ from book books0_ where books0_.author_id=?</pre>



<p>In the next step, Spring Data uses the <em>Author</em> entity object to instantiate the generated implementation of the <em>AuthorView</em> interface. From a performance point of view, this is the wrong approach. Your query is selecting too many columns and your persistence provider needs to manage another entity object. Because of that, the performance of this projection is worse than the performance of a DTO projection without a mapped association.</p>



<h4><span id="Using_Spring8217s_Expression_Language">Using Spring&#8217;s Expression Language</span></h4>



<p>You can also use Spring&#8217;s expression language in your interface definition. This enables you to provide an expression that will be processed at runtime to map one or more entity attributes to a DTO attribute.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface BookSummary {

	@Value(&quot;#{target.title + &#039;-&#039; + target.author.firstName}&quot;)
	String getBookNameAndAuthorName();
}</pre>



<p>In the above example, Spring will concatenate the&nbsp;<em>Book&#8217;s title&nbsp;</em>and the&nbsp;<em>firstName&nbsp;</em>attribute of the associated&nbsp;<em>Author&nbsp;</em>to set the attribute&nbsp;<em>bookNameAndAuthorName</em>. </p>



<p>Internally, this projection uses the same approach as I explained before. Spring Data JPA fetches a <em>Book </em>entity and uses it to perform a programmatic mapping.</p>



<h2><span id="Entity_Projections">Entity Projections</span></h2>



<p>Entities are the most commonly used projections. The persistence context manages all entities returned by a Spring Data repository. So, each change of an attribute will be persisted in the database and you can fetch <a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">lazily initialized associations</a>. This creates <a href="https://thorben-janssen.com/entities-dtos-use-projection/">performance overhead</a> for read operations but makes entities the optimal projection for all write operations. </p>



<p>Entity projections are by far the easiest to use. All standard query methods provided by the Spring Data JPA repository methods return them. And, if you define your own repository method, you only need to use the entity class as the return type.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {
	@Query(&quot;select a from Author a left join fetch a.books&quot;)
	List&lt;Author&gt; getAuthorsAndBook();
}</pre>



<p>Spring Data JPA then uses the mapping provided by the persistence provider. It selects all columns mapped by the entity classes and maps each returned record to a managed entity object.</p>



<h2><span id="Dynamic_Projections">Dynamic Projections</span></h2>



<p>Add a type class parameter to your repository method to use the same query with different projections. This enables you to define the preferred returned type in your business code.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {
	&lt;T&gt; T findByLastName(String lastName, Class&lt;T&gt; type);	
}</pre>



<p>Depending on the class you provide when you call the repository method, Spring Data JPA uses one of the previously described mechanisms to define the projection and map it. For example, if you provide a DTO class, Spring Data JPA generates a query with a constructor expression. Your persistence provider then selects the required database columns and returns a DTO object.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">AuthorSummaryDTO authorSummaryDTO = authorRepo.findByLastName(&quot;Janssen&quot;, AuthorSummaryDTO.class);</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Spring Data JPA supports all three projections defined by the JPA specification. Entities are the best fit for write operations. Moreover, you should use class-based DTO projections for read operations. </p>



<p>All other forms of projections are better avoided. Scalar value projections are very uncomfortable to use and make your code hard to maintain. Interface-based DTO projections donâ€™t perform well because they fetch entities and map them in an additional step.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>