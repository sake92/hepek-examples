<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Java Records – How to use them with Hibernate and JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Java Records – How to use them with Hibernate and JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>A lot of developers complain that Java is too verbose. And I can understand that, especially for all classes that are supposed to be a basic data structure, like JPA/Hibernate entities or <a href="https://thorben-janssen.com/dto-projections/">DTOs</a>. So, it was no surprise that I got a lot of questions about JDK&#8217;s records feature and how you can use it with Hibernate.</p>



<p>Let me immediately answer the 2 most common questions before we get into the details:</p>



<ol><li>Yes, Java records are a great fit for your persistence layer.</li><li>But no, you can’t implement an entity using a record.</li></ol>



<p>That&#8217;s because of a few important differences between the implementation of a Java record and the requirements of an entity, which I will explain in this article.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Records_in_Java"><span class="toc_number toc_depth_1">1</span> Records in Java</a></li><li><a href="#Records_can8217t_be_entities"><span class="toc_number toc_depth_1">2</span> Records can&#8217;t be entities</a></li><li><a href="#Records_are_great_DTOs"><span class="toc_number toc_depth_1">3</span> Records are great DTOs</a><ul><li><a href="#Instantiating_a_record_in_JPQL"><span class="toc_number toc_depth_2">3.1</span> Instantiating a record in JPQL</a></li><li><a href="#Instantiating_a_record_in_a_CriteriaQuery"><span class="toc_number toc_depth_2">3.2</span> Instantiating a record in a CriteriaQuery</a></li><li><a href="#Instantiating_a_record_from_a_native_query"><span class="toc_number toc_depth_2">3.3</span> Instantiating a record from a native query</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="Records_in_Java">Records in Java</span></h2>



<p>Records is a <a href="https://openjdk.java.net/jeps/359">preview feature in Java 14</a>. Its main goal is to provide a way to handle data as data and to simplify the declaration of an immutable data structure.</p>



<p>Here you can see the declaration of the <em>BookWithAuthorNamesRecord</em>. It stores the <em>id</em>, <em>title</em>, and <em>price </em>of a book and the names of its authors.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">record BookWithAuthorNamesRecord(
		Long bookId, 
		String title, 
		Double price, 
		String authorNames) {}</pre>



<p>Records are implicitly final. By declaring a record with its components, you automatically create a private final field and a public read accessor method for each component. A Java record also provides you with a constructor that initializes all of its fields and implementations for the <a href="https://thorben-janssen.com/ultimate-guide-to-implementing-equals-and-hashcode-with-hibernate/">equals(), hashCode()</a>, and toString() methods.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">BookWithAuthorNamesRecord b = new BookWithAuthorNamesRecord(
		1L, 
		&quot;Hibernate Tips - More than 70 solutions to common Hibernate problems&quot;, 
		19.99D, 
		&quot;Thorben Janssen&quot;);
log.info(b.title() + &quot; was written by &quot;+b.authorNames());</pre>



<p>As you can see, records are a straightforward and clean option to implement a read-only data structure. But as I will explain in the next section, some of the features that make a record easy to use also make it impossible to implement an entity with it.</p>



<h2><span id="Records_can8217t_be_entities">Records can&#8217;t be entities</span></h2>



<p>As I explain in the <a href="https://thorben-janssen.com/jpa-for-beginners/">JPA for Beginners online course</a>, a JPA-compliant entity needs to fulfill a few simple requirements. It needs to:</p>



<ul><li>be annotated with @Entity,</li><li><strong>have a public or protected parameterless constructor so that the persistence provider can instantiate objects when mapping query results,</strong></li><li>be a top-level class,</li><li><strong>not be final so that your persistence provider can generate proxies, e.g., to offer lazy loading for to-one associations,</strong></li><li>declare one or more attributes that identify the entity object,</li><li><strong><strong>map database columns to non-final attributes and</strong></strong></li><li><strong><strong>provide getter and setter methods to access these attributes.</strong></strong></li></ul>



<p>If you&#8217;re implementing your entity as a standard Java class, these requirements are easy to fulfill. But the 4 requirements that I highlighted make it impossible to implement an entity as a Java record. Records don&#8217;t support a parameterless constructor, and they are final, which entities are not allowed to be. The fields of a record are also final, and their accessor methods don&#8217;t follow the required naming schema.</p>



<p>As you can see, you can&#8217;t implement a JPA-compliant entity using a Java record. Hibernate&#8217;s requirements are not as strict as JPA&#8217;s requirements. Hibernate can persist final classes and doesn&#8217;t require any <a href="https://thorben-janssen.com/access-strategies-in-jpa-and-hibernate/">accessor methods for mapped entity attributes</a>. But it still requires a default constructor and non-final fields.</p>



<p>All of this makes it impossible to use a Java record to implement an entity. But it&#8217;s a good fit for a DTO projection, which is often used as a read-only representation of the data stored in your database.</p>



<h2><span id="Records_are_great_DTOs">Records are great DTOs</span></h2>



<p>DTOs are the <a href="https://thorben-janssen.com/dto-projections/">best projection</a> if you don&#8217;t want to change the selected information. They provide <a href="https://thorben-janssen.com/entities-dtos-use-projection/">better performance</a> than entities and allow you to <a href="https://thorben-janssen.com/dont-expose-entities-in-api/">decouple your domain model from your API</a>.</p>



<p>The best way to instantiate a DTO projection is to tell Hibernate to map the query result to a DTO object. You can do that using a constructor expression in JPQL and the Criteria API. If you want to map the result of a native query, you can use a <a href="https://thorben-janssen.com/result-set-mapping-constructor-result-mappings/"><em>@SqlResultSetMapping</em></a>. All 3 of these approaches tell Hibernate which constructor it has to call and which parameter values it shall provide. </p>



<p>If you prefer a more flexible approach, you can use a <a href="https://thorben-janssen.com/hibernate-resulttransformer/">Hibernate-specific <em>ResultTransformer</em></a>. Unfortunately, the most commonly used <em>ResultTransformers </em>expect your DTO class to follow the JavaBeans convention by providing getter and setter methods. As explained earlier, Java records don&#8217;t do that. In most situations, I would, therefore, use one of JPA&#8217;s constructor expressions.</p>



<p>The constructor expressions supported by JPA require a constructor that sets all attributes of the DTO object. The constructor of a record is a perfect match for that, and Hibernate can call it in the same way as it calls the constructor of a regular Java class.</p>



<h3><span id="Instantiating_a_record_in_JPQL">Instantiating a record in JPQL</span></h3>



<p>The constructor expression in a <a href="https://thorben-janssen.com/jpql/">JPQL query</a> consists of the keyword new, the fully qualified class name, and a list of constructor parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;BookWithAuthorNamesRecord&gt; q = 
		em.createQuery(
				&quot;SELECT new org.thoughts.on.java.model.BookWithAuthorNamesRecord(&quot;
						+ &quot;b.id, b.title, b.price, concat(a.firstName, &#039; &#039;, a.lastName)) &quot;
				+ &quot; FROM Book b JOIN b.author a &quot;
				+ &quot; WHERE b.title LIKE :title&quot;,
				BookWithAuthorNamesRecord.class);
q.setParameter(&quot;title&quot;, &quot;%Hibernate Tips%&quot;);
List&lt;BookWithAuthorNamesRecord&gt; books = q.getResultList();</pre>



<p>After you executed the query and retrieved the instance of the <em>BookWithAuthorNamesRecord</em>, you can use it in your business code.</p>



<h3><span id="Instantiating_a_record_in_a_CriteriaQuery">Instantiating a record in a <em>CriteriaQuery</em></span></h3>



<p>You can use the <em>construct </em>method of JPA&#8217;s <em>CriteriaBuilder </em>to define a constructor call in your <em>CriteriaQuery</em>. The first method parameter is a reference to the class Hibernate shall instantiate, and all other parameters will be used as constructor parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">// Create query
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&lt;BookWithAuthorNamesRecord&gt; cq = cb
		.createQuery(BookWithAuthorNamesRecord.class);
// Define FROM clause
Root&lt;Book&gt; root = cq.from(Book.class);
Join&lt;Book, Author&gt; author = root.join(Book_.author);

// Define DTO projection
cq.select(cb.construct(
		BookWithAuthorNamesRecord.class,
		root.get(Book_.id),
		root.get(Book_.title),
		root.get(Book_.price),
		cb.concat(cb.concat(author.get(Author_.firstName), &quot; &quot;),
				author.get(Author_.lastName))));

// Define WHERE clause
ParameterExpression&lt;String&gt; paramTitle = cb.parameter(String.class);
cq.where(cb.like(root.get(Book_.title), paramTitle));

// Execute query
TypedQuery&lt;BookWithAuthorNamesRecord&gt; q = em.createQuery(cq);
q.setParameter(paramTitle, &quot;%Hibernate Tips%&quot;);
List&lt;BookWithAuthorNamesRecord&gt; books = q.getResultList();</pre>



<h3><span id="Instantiating_a_record_from_a_native_query">Instantiating a record from a native query</span></h3>



<p><a href="https://thorben-janssen.com/jpa-native-queries/">Native queries</a> don&#8217;t get parsed by your JPA implementation. They get directly send to the database. Due to that, you can&#8217;t use a constructor expression as we did in the JPQL example.</p>



<p>But you can use a <a href="https://thorben-janssen.com/result-set-mapping-basics/"><em>@SqlResultSetMapping</em> annotation</a> to define the result mapping. The following example defines a mapping with the name <em>BookWithAuthorNamesRecordMapping</em>. It tells Hibernate to instantiate an object of the <em>BookWithAuthorNamesRecord </em>record and to use the <em>title</em>, <em>author</em>,<em> </em>and <em>publisher </em>fields of the result set record as constructor parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@SqlResultSetMapping(
		name = &quot;BookWithAuthorNamesRecordMapping&quot;,
		classes = @ConstructorResult(
				targetClass = BookWithAuthorNamesRecord.class,
				columns = { @ColumnResult(name = &quot;id&quot;, type = Long.class), 
							@ColumnResult(name = &quot;title&quot;), 
							@ColumnResult(name = &quot;price&quot;), 
							@ColumnResult(name = &quot;authorName&quot;)}))
public class Book { ... }</pre>



<p>In the next step, you need to provide the name of this mapping as the 2nd parameter to the <em>createNativeQuery </em>method. Hibernate will then apply the defined mapping to each record in the result set.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q = em.createNativeQuery(
				&quot;SELECT b.id, b.title, b.price, a.firstName || a.lastName as authorName FROM Book b JOIN Author a ON b.author_id = a.id WHERE b.title LIKE :title&quot;,
				&quot;BookWithAuthorNamesRecordMapping&quot;);
q.setParameter(&quot;title&quot;, &quot;%Hibernate Tips%&quot;);
List&lt;BookWithAuthorNamesRecord&gt; books = q.getResultList();

for (BookWithAuthorNamesRecord b : books) {
	log.info(b);
}</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Java records are an interesting feature to represent immutable data structures. Compared to regular Java classes, they introduce a few restrictions that don&#8217;t fulfill JPA&#8217;s and Hibernate&#8217;s requirements of an entity class. But they are an excellent solution for DTO projections.</p>



<p>DTO&#8217;s are often read-only, and the constructor provided by a Java record is an ideal match for JPA&#8217;s constructor expression. This makes them an efficient and obvious choice for all queries that return data that you don&#8217;t want to change.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>