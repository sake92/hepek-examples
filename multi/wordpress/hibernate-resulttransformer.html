<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Hibernate’s ResultTransformer in Hibernate 4, 5 &amp; 6</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" /><style>
    nav#tocScrollspy {
      display: none;
    }

    @media (min-width: 991px) {
      .affix {
          position: fixed;
          width: 10%;
      }

      nav#tocScrollspy {
        display: block;
      }
    }
    </style></head><body><div class="container-fluid"><div><div class="page-header text-center"><h1>Hibernate’s ResultTransformer in Hibernate 4, 5 &amp; 6</h1></div><div class="row"><div class="col-lg-2 col-md-0 invisible"></div><div class="col-lg-8 col-md-12">
<p>Hibernate implements JPA&#8217;s standardized <a href="https://thorben-janssen.com/dto-projections/">constructor expressions</a> and <a href="https://thorben-janssen.com/result-set-mapping-basics/">@SqlResultSetMappings</a> to map the results of your queries. And it also supports proprietary ResultTransformers. They provide a powerful and flexible way to map the result of your <a href="https://thorben-janssen.com/jpql/">JPQL</a>, Criteria, and <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL query</a> to a specific object structure. This can be entity or DTO objects, <em>java.util.List</em> or <em>java.util.Map</em> representations of each record, or a custom data structure.</p>



<p><em>ResultTransformers </em>were especially popular with Hibernate 4 but got deprecated in Hibernate 5. Unfortunately, Hibernate 5 doesn&#8217;t provide an alternative for them. Due to that, it might look like <em>ResultTransformer </em>would be removed in Hibernate 6. But that&#8217;s not the case! </p>



<p>Hibernate 6 will provide an improved version of <em>ResultTranformers </em>based on 2 functional interfaces. Based on the current code in the Hibernate 6 repository, migrating your existing <em>ResultTransformer </em>shouldn&#8217;t be a big deal.</p>



<h2 class="wp-block-heading">ResultTransformer in Hibernate 4 and 5</h2>



<p>Hibernate 4 and 5 include several build-in <em>ResultTransformer</em>. In addition, you can provide your own implementations. But before we talk about the different <em>ResultTransformers</em>, let me show you how to apply them to your query.</p>



<p>You only need to provide an instance of your <em>ResultTransformer </em>to the <em>setResultTransformer</em> method of Hibernate&#8217;s&nbsp;<em>Query</em>&nbsp;interface. If you&#8217;re using JPA&#8217;s <em>EntityManager </em>and <em>Query </em>interface, you need to unwrap them. If you unwrap the <em>EntityManager</em>, you get the associated Hibernate <em>Session</em>. If you unwrap JPA&#8217;s <em>Query </em>interface, you get Hibernate&#8217;s <em>Query</em> interface. I explained that in more detail in the <a href="https://thorben-janssen.com/hibernate-tips-access-hibernate-apis-jpa/">Hibernate Tip: How to access Hibernate APIs from JPA</a>.</p>



<p>OK, let&#8217;s take a look at some of the commonly used <em>ResultTransformers </em>in Hibernate 4 and 5.</p>



<h3 class="wp-block-heading">AliasToBeanResultTransformer</h3>



<p>JPA enables you to map each record in your query result to an unmanaged DTO object. You can define these mappings using a <a href="https://thorben-janssen.com/jpql/">constructor expression in JPQL</a> or a <a href="https://thorben-janssen.com/result-set-mapping-constructor-result-mappings/">@ConstructorResult</a> for native queries. Both of these options require you to add a constructor to your DTO class that sets all attributes. This can be problematic if your DTO class has a huge number of attributes.</p>



<p>Hibernate&#8217;s <em>AliasToBeanResultTransformer </em>provides another way based on the bean specification. It uses the default constructor of the DTO class to instantiate a new object. In the next step, Hibernate uses reflection to call a setter method for each aliased value in the query. That makes it a great fit for DTOs that are implemented as a standard Java class but not as a <a href="/java-records-hibernate-jpa/">Java record</a>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Query query = session.createQuery(&quot;select p.id as personId,p.firstName as firstName, p.lastName as lastName from Person p&quot;)
    .setResultTransformer(new AliasToBeanResultTransformer(PersonDTO.class));
List&lt;PersonDTO&gt; personDTOS = query.list();
</pre></div>


<p>In this example, the <em>AliasToBeanResultTransformer </em>uses the default constructor to instantiate a new <em>PersonDTO </em>object for each record returned by the query. In the next step, Hibernate calls the methods <em>setPersonId</em>, <em>setFirstName, </em>and <em>setLastName </em>with the values returned by the query.</p>



<h3 class="wp-block-heading">ToListResultTransformer and AliasToEntityMapResultTransformer</h3>



<p>If you don&#8217;t want to change the selected data and don&#8217;t have a matching DTO class, you can use Hibernate&#8217;s <em>ToListResultTransformer </em>or <em>AliasToEntityMapResultTransformer</em>. The <em>ToListResultTransformer </em>maps the <em>Object[]</em> returned by your query with all its elements to a <em>java.util.List</em>. The <em>AliasToEntityMapResultTransformer </em>transforms the query result to a <em>java.util.Map </em>that contains all aliased values of the result set. The alias of each value is used as the key of the <em>Map</em>.</p>



<p>Here you can see an example of the <em>AliasToEntityMapResultTransformer</em>. You can use the <em>ToListResultTransformer </em>in the same way.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Query selectPerson = session.createQuery(
    &quot;Select p.id as id, &quot; +
    &quot;p.firstName as firstName, &quot; +
    &quot;p.lastName as lastName &quot; +
    &quot;from Person p&quot;)
    .setResultTransformer(AliasToEntityMapResultTransformer.INSTANCE);
List&lt;Map&gt; list = selectPerson.list();
</pre></div>


<h3 class="wp-block-heading">Implementing your own ResultTransformer</h3>



<p>If you want to implement your own <em>ResultTransformer </em>with Hibernate 4 or 5, you need to implement Hibernate&#8217;s <em>ResultTransformer </em>interface. That interface defines 2 methods: the <em>transformTuple </em>and the <em>transformList</em> methods.</p>



<p>A common <em>ResultTransformer </em>implementation implements the mapping of each record in the <em>transformTuple </em>method. The <em>transformList </em>method only returns the provided list of tuples.</p>



<p>I use that approach in the following code snippet to implement my own <em>ResultTransformer </em>that maps each record to a <em>PersonDTO </em>object.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Query query = session.createNativeQuery(&quot;select id as personId, first_name as firstName, last_name as lastName, city from Person p&quot;)
    .setResultTransformer(new ResultTransformer(){
            @Override
            public Object transformTuple(Object&#x5B;] tuples, String&#x5B;] aliases) {
                PersonDTO personDTO = new PersonDTO();
                personDTO.setPersonId((int)tuples&#x5B;0]);
                personDTO.setFirstName((String)tuples&#x5B;1]);
                personDTO.setLastName((String)tuples&#x5B;2]);
                return personDTO;
            }
 
            @Override
            public List transformList(List list) {
                return list;
            }
        });
List&lt;PersonDTO&gt; list = query.list();
</pre></div>


<h2 class="wp-block-heading">ResultTransformer in Hibernate 6</h2>



<p>When I described the implementation of a custom <em>ResultTransformer </em>in Hibernate 4 and 5, I also mentioned one of the downsides of the <em>ResultTransformer </em>interface. It defines the <em>transformTuple </em>and <em>transformList </em>methods that both need to be implemented. Most applications implement only 1 of these 2 methods in a meaningful way. But because both methods are part of the interface definition, you need to implement both of them and can&#8217;t use the <em>ResultTransformer </em>as a functional interface in lambda expressions.</p>



<p>This changed in Hibernate 6. The Hibernate team has split the <em>ResultTransformer </em>interface into the 2 functional interfaces: <em>TupleTransformer </em>and <em>ResultListTransformer</em>. You can set them by calling the <em>setTupleTransformer</em> and <em>setResultListTransformer </em>methods on Hibernate&#8217;s <em>Query </em>interface.</p>



<p>The Hibernate team also converted the <em>ResultTransformer </em>implementations provided by Hibernate 4 and 5 to <em>TupleTransformer</em> or <em>ResultListTransformer</em> implementations in Hibernate 6. Due to that, the required changes when migrating your application to Hibernate 6 should be minimal.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Query query = session.createQuery(&quot;select p.id as personId,p.firstName as firstName, p.lastName as lastName from Person p&quot;)
    .setTupleTransformer(new AliasToBeanResultTransformer&lt;PersonDTO&gt;(PersonDTO.class)).getSingleResult();
List&lt;PersonDTO&gt; personDTOS = query.list();
</pre></div>


<p>And as you can see in the following code snippet, the implementation of a custom transformer in Hibernate 6 is much more concise.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
PersonDTO person = (PersonDTO) session
        .createQuery(&quot;select id as personId, first_name as firstName, last_name as lastName, city from Person p&quot;, Object&#x5B;].class)
        .setTupleTransformer((tuples, aliases) -&gt; {
                log.info(&quot;Transform tuple&quot;);
                PersonDTO personDTO = new PersonDTO();
                personDTO.setPersonId((int)tuples&#x5B;0]);
                personDTO.setFirstName((String)tuples&#x5B;1]);
                personDTO.setLastName((String)tuples&#x5B;2]);
                return personDTO;
        }).getSingleResult();
</pre></div>


<h2 class="wp-block-heading">Conclusion</h2>



<p>Hibernate&#8217;s <em>ResultTransformers </em>provide various ways to map the result of your query to different data structures. They were commonly used in Hibernate 4, got deprecated in Hibernate 5 and got replaced by the functional interfaces <em>TupleTransformer</em> and <em>ResultListTransformer</em> in Hibernate 6.</p>



<p>The following list shows the 3 most commonly used <em>ResultTransformer</em>s in Hibernate 4 and 5. These are still available in Hibernate 6 and now implement the <em>TupleTransformer</em> and/or <em>ResultListTransformer </em>interfaces.</p>



<ul>
<li><em>AliasToBeanResultTransformer</em> &#8211; Instantiates and sets attributes on DTO objects based on the alias defined in the query.</li>



<li><em>ToListResultTransformer</em>&#8211; Maps each record in the query result to a <em>java.util.List</em>.</li>



<li><em>AliasToEntityMapResultTransformer</em> &#8211; Maps the aliased values of each record in the query result to a java.util.Map.</li>
</ul>



<p>You can also implement your own transformation: </p>



<ul>
<li>In Hibernate 4 and 5, you need to implement the <em>ResultTransformer </em>interface and handle the mapping of each result set record in the <em>transformTuple</em> method.</li>



<li>In Hibernate 6, you need to implement the functional interfaces <em>TupleTransformer</em> or <em>ResultListTransformer</em>. </li>
</ul>
</div><div class="col-lg-2 col-md-0 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script></body></html>