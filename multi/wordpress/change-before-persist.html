<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>How to change an attribute before INSERT and UPDATE</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>How to change an attribute before INSERT and UPDATE</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>In a<a href="/use-database-features-hibernate/#comment-69878"> comment here on the blog</a>, Mehmet asked how he could call a function before inserting or updating an entity in the database.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="/use-database-features-hibernate/#comment-69878"><img width="779" height="454" src="https://thorben-janssen.com/wp-content/uploads/2020/09/Change-attribute-before-write-Comment-1.png" alt="" class="wp-image-26605" srcset="https://thorben-janssen.com/wp-content/uploads/2020/09/Change-attribute-before-write-Comment-1.png 779w, https://thorben-janssen.com/wp-content/uploads/2020/09/Change-attribute-before-write-Comment-1-300x175.png 300w, https://thorben-janssen.com/wp-content/uploads/2020/09/Change-attribute-before-write-Comment-1-768x448.png 768w, https://thorben-janssen.com/wp-content/uploads/2020/09/Change-attribute-before-write-Comment-1-400x233.png 400w" sizes="(max-width: 779px) 100vw, 779px" /></a></figure></div>



<p>There are several ways you can call a function as part of an SQL INSERT or UPDATE statement. But these are not your only options. To change an attribute&#8217;s value before the statement gets executed, you can&nbsp;</p>



<ol><li>add code to the setter method,</li><li>implement a lifecycle callback,</li><li>define a Hibernate-specific @ColumnTransformer,</li><li>provide custom SQL INSERT and UPDATE statements.</li></ol>



<p>Let&#8217;s take a look at all 4 options.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Option_1_Customize_your_Setter_Method"><span class="toc_number toc_depth_1">1</span> Option 1: Customize your Setter Method</a></li><li><a href="#Option_2_Lifecycle_Callback"><span class="toc_number toc_depth_1">2</span> Option 2: Lifecycle Callback</a></li><li><a href="#Option_3_ColumnTransformer"><span class="toc_number toc_depth_1">3</span> Option 3: @ColumnTransformer</a></li><li><a href="#Option_4_Custom_SQL_INSERT_and_UPDATE_statements"><span class="toc_number toc_depth_1">4</span> Option 4: Custom SQL INSERT and UPDATE statements</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">5</span> Conclusion</a></li></ul></div>
<h2><span id="Option_1_Customize_your_Setter_Method">Option 1: Customize your Setter Method</span></h2>



<p>By far, the easiest approach to adapt the value of an attribute before it gets persisted is to add the required code to the setter method. I use this in the following code snippet to trim leading and trailing whitespaces when setting the description attribute.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

    ...

    private String description;

    public void setDescription(String description) {
        this.description = description.trim();
    }
	
    ...
}</pre>



<p>This approach&#8217;s advantage is that it doesn’t require any external trigger to trim the description <em>String</em>. But it also has the disadvantage that you execute this operation every time the setter method gets called.</p>



<p>To prevent Hibernate from triggering this operation every time it gets an entity from the database, you should annotate your primary key attribute with the <em>@Id</em> annotation. This tells Hibernate to use <a href="/access-strategies-in-jpa-and-hibernate/">field-based access</a> for this entity. It will then use reflection to set the entity attributes instead of the getter methods.</p>



<h2><span id="Option_2_Lifecycle_Callback">Option 2: Lifecycle Callback</span></h2>



<p>As I explained in a previous article, each entity object has a lifecycle. Depending on the operation performed, the object changes its lifecycle state. You can implement lifecycle callbacks that Hibernate triggers when an entity changes its lifecycle state.</p>



<p>Suppose you want to trigger an operation before Hibernate executes an SQL INSERT or UPDATE statement for a specific entity class. In that case, you can add a custom method to that class and annotate it with <em>@PreInsert</em> and <em>@PreUpdate</em>. This tells Hibernate to call that method after you called the <em>EntityManager.persist</em> method, but before executing the SQL UPDATE statement.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

    ...

    private String description;

    @PrePersist
    @PreUpdate
    void removeWhitespace() {
        this.description = this.description.trim();
    }
	
    ...
}</pre>



<p>Within this method, you can only perform operations on that entity object. This might be a limitation in some situations. But it&#8217;s more than good enough to implement a validation or change a value before it gets persisted.</p>



<p>As you can see, I annotated the <em>removeWhitespace </em>method with <em>@PrePersist</em> and <em>@PreUpdate</em>. It contains the same code as I added to the setter method in the previous section. Please keep in mind that the code in your lifecycle callback doesn&#8217;t get called until you persist a new entity, or Hibernate executes the SQL UPDATE statement. In the example, that means my business code can’t expect that the <em>String </em>in the description attribute has been trimmed. It needs to be able to handle trimmed and untrimmed descriptions.</p>



<h2><span id="Option_3_ColumnTransformer">Option 3: @ColumnTransformer</span></h2>



<p>To trigger a database function instead of implementing it in your Java code, you can use a <a href="/map-encrypted-database-columns-hibernates-columntransformer-annotation/">@ColumnTransformer</a>. It enables you to define a native SQL snippet used for all write operations. You can also provide one for each read operation.</p>



<p>In this article&#8217;s example, you could call the database function <em>trim</em> to remove leading and trailing whitespace from the <em>description</em> while writing it to the database. And because there is no need for any adjustments during read operations, you don&#8217;t need to specify the <em>read </em>attribute of the <em>@ColumnTransformer</em> annotation.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

    ...

    @ColumnTransformer(write = &quot;trim(?)&quot;)
    private String description;
    
    ...
}</pre>



<p>This is very similar to the <em>@Formula</em> annotation, which Mehmet mentioned in his question. This approach&#8217;s main advantage is that you provide a native SQL snippet that Hibernate embeds in all write operations. That enables you to use all features supported by your database and doesn&#8217;t limit you to Hibernate&#8217;s feature set. But if you deploy your application using multiple DBMS, you also need to make sure that all of them support the database function.</p>



<h2><span id="Option_4_Custom_SQL_INSERT_and_UPDATE_statements">Option 4: Custom SQL INSERT and UPDATE statements</span></h2>



<p>And the 4th option is to define custom SQL INSERT and UPDATE statements for the entity class. This approach is similar to the one I described in my article about implementing a <a href="https://thorben-janssen.com/implement-soft-delete-hibernate/">soft-delete with Hibernate</a>.</p>



<p>Hibernate’s <em>@SQLInsert</em> and <em>@SQLUpdate</em> statements enable you to define the native SQL statement used to persist and update an entity. You can use them to call a database function that changes the value of an entity attribute while persisting it in the database.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@SQLInsert(sql = &quot;INSERT INTO Book (description, title, version, id) VALUES (trim(?), ?, ?, ?)&quot;)
@SQLUpdate(sql = &quot;UPDATE Book SET description = ?, title = ?, version = ? WHERE id = ? AND version = ?&quot;)
public class Book { ... }</pre>



<p>This approach is similar to the previously described <em>@ColumnTransformer</em>. In both cases, you are adjusting the SQL statement that inserts or updates the database records. But providing your own INSERT and UPDATE statements for an entity class is more complex than only providing the SQL snippet used for a specific attribute. Because of that, I prefer a <em>@ColumnTransformer</em> over a customized INSERT and UPDATE statement.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>You have multiple options to adapt the value of an entity attribute before persisting it in the database. </p>



<p>The easiest one is to add the required code to the setter method of your entity class. If you use <a href="/access-strategies-in-jpa-and-hibernate/">field-based access</a> and make sure that you don&#8217;t call this method multiple times within the same use case, this approach doesn&#8217;t have any side-effects. Because of that, this is my preferred approach to adapt the value of an entity attribute.</p>



<p>A lifecycle callback is your 2nd best option to change an entity attribute before persisting it. You can tell Hibernate to trigger it when you persist a new entity object and before it executes the SQL UPDATE statement. But please keep in mind that Hibernate tries to delay an UPDATE statement&#8217;s execution as long as possible. Because of that, your business logic needs to be able to handle values that haven&#8217;t been adjusted by the lifecycle callback.</p>



<p>If you can&#8217;t easily implement the required operations in your Java code, you can use a database function instead. The best way to do that is to use a @ColumnTransformer. It defines a native SQL snippet that Hibernate embeds in each SQL INSERT and UPDATE statement.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>