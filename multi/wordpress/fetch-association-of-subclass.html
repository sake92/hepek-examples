<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>The best way to fetch an association defined by a subclass</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>The best way to fetch an association defined by a subclass</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>EntityGraphs and JOIN FETCH clauses provide an easy and efficient way to fetch an entity and initialize its associations. But if you try to use it with a <a href="https://thorben-janssen.com/complete-guide-inheritance-strategies-jpa-hibernate/">domain model that uses inheritance</a>, you will quickly run into an issue: </p>



<p>You can&#8217;t use this approach in a polymorphic query to fetch an association that&#8217;s defined on a subclass. Or in other words, your JOIN FETCH clause or <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">EntityGraph</a> needs to reference an entity attribute that&#8217;s defined by your superclass. Otherwise, Hibernate will throw an exception because the attribute is unknown for some subclasses.</p>



<p>But there is an easy workaround based on Hibernate&#8217;s 1st level cache and its guarantee that there is only 1 entity object for each database record in a Hibernate Session. Let&#8217;s take a look at an example, and I&#8217;ll show you how this workaround works.</p>



<p>Note: This article was inspired by a <a href="https://stackoverflow.com/questions/61254061/jpa-inheritance-entitygraph-include-optional-associations-of-subclasses/61502729#61502729">question on StackOverflow</a> for which I was able to claim the bounty with an answer I prepared on a <a href="https://youtu.be/70B9znTmi00?t=233">Coffee with Thorben live stream</a>.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#The_domain_model"><span class="toc_number toc_depth_1">1</span> The domain model</a></li><li><a href="#Fetching_an_Author_with_their_BlogPosts_Books_and_Publishers"><span class="toc_number toc_depth_1">2</span> Fetching an Author with their BlogPosts, Books and Publishers</a><ul><li><a href="#Hibernate8217s_1st_level_cache_to_the_rescue"><span class="toc_number toc_depth_2">2.1</span> Hibernate&#8217;s 1st level cache to the rescue</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="The_domain_model">The domain model</span></h2>



<p>The model used in this article is simple. An <em>Author</em> can write different kinds of <em>Publication</em>s, like <em>Book</em>s and <em>BlogPost</em>s. These 2 kinds of <em>Publication</em>s share the attributes id, version, title, <em>publishingDate, </em>and a reference to the <em>Author</em>. <em>BlogPost</em>s get published on their author&#8217;s blog, so they have the additional attribute <em>url</em>. <em>Book</em>s might be published by a <em>Publisher</em>, which I modeled as a reference to another entity in our small domain model.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img width="408" height="257" src="https://thorben-janssen.com/wp-content/uploads/2020/06/Class-diamgram-association-mapping-2.png" alt="" class="wp-image-26255" srcset="https://thorben-janssen.com/wp-content/uploads/2020/06/Class-diamgram-association-mapping-2.png 408w, https://thorben-janssen.com/wp-content/uploads/2020/06/Class-diamgram-association-mapping-2-300x189.png 300w, https://thorben-janssen.com/wp-content/uploads/2020/06/Class-diamgram-association-mapping-2-400x252.png 400w" sizes="(max-width: 408px) 100vw, 408px" /></figure></div>



<p>There is nothing special about the entity mappings. I use the <em><a href="https://thorben-janssen.com/complete-guide-inheritance-strategies-jpa-hibernate#singleTable">InheritanceType.SINGLE_TABLE</a></em> to map the <em>Publication</em>, <em>Book, </em>and <em>BlogPost </em>entities to the same database table. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public abstract class Publication {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	protected Long id;
	
	protected String title;	
	
	@Version
	private int version;
	
	@ManyToOne(fetch = FetchType.LAZY)
	protected Author author;
	
	protected LocalDate publishingDate;

	...
}</pre>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@DiscriminatorValue(&quot;Blog&quot;)
public class BlogPost extends Publication {

	private String url;

	...
}</pre>



<p>The Book entity also defines a <a href="https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/">one-to-many association</a> to the <em>Publisher </em>entity.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@DiscriminatorValue(&quot;Book&quot;)
public class Book extends Publication {

	private int pages;

	@ManyToOne
	private Publisher publisher;

	...
}</pre>



<p>The <em>InheritanceType.SINGLE_TABLE</em> enables us to define a polymorphic <a href="https://thorben-janssen.com/best-practices-many-one-one-many-associations-mappings/">one-to-many association</a> mapping between the <em>Author </em>and the <em>Publication </em>entity. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Author {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;
	
	@Version
	private int version;

	private String firstName;

	private String lastName;

	@OneToMany(mappedBy=&quot;author&quot;)
	private Set&lt;Publication&gt; publications = new HashSet&lt;Publication&gt;();

	...
}</pre>



<h2><span id="Fetching_an_Author_with_their_BlogPosts_Books_and_Publishers">Fetching an Author with their BlogPosts, Books and Publishers</span></h2>



<p>OK, let&#8217;s answer our initial question: How can you initialize the association between the <em>Book </em>and the <em>Publisher </em>entity if you get an Author with all their <em>Publication</em>?</p>



<p>If you expected to do this in 1 query, I have to disappoint you. Hibernate doesn&#8217;t support that. But using the following workaround, you only need 2 queries. That is much better than the <a href="https://thorben-janssen.com/free-n1_select_course/">n+1 queries</a> you would need without it.</p>



<p>So, how does it work? As I said, Hibernate only supports JOIN FETCH clauses or EntityGraphs on attributes that are defined by all entity classes of a polymorphic association. Due to that, you need an extra query to get the <em>Book</em>s with their <em>Publisher</em>s. In the next step, you then need to reuse these objects when processing the results of the 2nd query.</p>



<h3><span id="Hibernate8217s_1st_level_cache_to_the_rescue">Hibernate&#8217;s 1st level cache to the rescue</span></h3>



<p>By using Hibernate&#8217;s 1st level cache and its guarantee that within a Hibernate Session, a database record gets only mapped by 1 entity object, you can implement this very efficiently. Your 1st query gets all the <em>Book </em>entities and their <em>Publisher</em>, which you need for your use case. </p>



<p>In this example, these are all <em>Book</em>s written by an <em>Author</em> with the <em>firstName</em> Thorben. As you can see, the query isn&#8217;t too complex. I join from the <em>Book </em>to the <em>Author </em>to be able to define the WHERE clause, and I use a JOIN FETCH clause to initialize the association between the <em>Book</em> and the <em>Publisher</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q1 = em.createQuery(&quot;SELECT b FROM Book b JOIN b.author a JOIN FETCH b.publisher p WHERE a.firstName = :fName&quot;);
</pre>



<p>When Hibernate processes the result of this query, it adds all entity objects to its 1st level cache. When it then needs to process the result of another query which returns <em>Book</em> entities, Hibernate first checks if that entity object is already stored in the 1st level cache. If that&#8217;s the case, it gets it from there.</p>



<p>This is the key element of this workaround. It enables you in the 2nd query to ignore the association between the <em>Book </em>and the <em>Publisher </em>entity. Because Hibernate will get all <em>Book </em>entity objects from the 1st level cache, the association to the <em>Publisher </em>entity will be initialized anyways.</p>



<p>Here you can see the query that gets all <em>Publication</em>s of the <em>Author </em>with the <em>firstName </em>Thorben. Thanks to the <a href="https://thorben-janssen.com/composition-vs-inheritance-jpa-hibernate/">inheritance mapping</a> and the mapped one-to-many association, this query is very simple.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q2 = em.createQuery(&quot;SELECT p FROM Publication p JOIN p.author a WHERE a.firstName = :fName&quot;, Publication.class);
</pre>



<p>Let&#8217;s try this workaround using the following test case. It first executes the 2 described queries and then writes a log message for each retrieved <em>Publication</em>. If the <em>Publication </em>is a <em>Book</em>, this log message includes the name of the <em>Publisher</em>. And I also included log messages that will show the object reference of the <em>Book </em>entity objects. This will show you that Hibernate always returns the same object instance for the <em>Book</em> entity.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q1 = em.createQuery(&quot;SELECT b FROM Book b JOIN b.author a JOIN FETCH b.publisher p WHERE a.firstName = :fName&quot;);
q1.setParameter(&quot;fName&quot;, &quot;Thorben&quot;);
List&lt;Book&gt; bs = q1.getResultList();
for (Book b : bs) {
	log.info(b);
}

Query q2 = em.createQuery(&quot;SELECT p FROM Publication p JOIN p.author a WHERE a.firstName = :fName&quot;, Publication.class);
q2.setParameter(&quot;fName&quot;, &quot;Thorben&quot;);
List&lt;Publication&gt; ps = q2.getResultList();

for (Publication p : ps) {
	if (p instanceof BlogPost) {
		BlogPost blog = (BlogPost) p;
		log.info(&quot;BlogPost - &quot;+blog.getTitle()+&quot; was published at &quot;+blog.getUrl());
	} else {
		Book book = (Book) p;
		log.info(&quot;Book - &quot;+book.getTitle()+&quot; was published by &quot;+book.getPublisher().getName());
		log.info(book);
	}
}</pre>



<p>As you can see in the log file, Hibernate only executed the 2 expected queries. Even though the 2nd query did not initialize the association between the <em>Book</em> and the <em>Publisher</em>, the lazily fetched association is available. As the logged object references show, Hibernate used the same <em>Book</em> entity object in the result of both queries.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">12:18:05,504 DEBUG [org.hibernate.SQL] - select book0_.id as id2_1_0_, publisher2_.id as id1_2_1_, book0_.author_id as author_i8_1_0_, book0_.publishingDate as publishi3_1_0_, book0_.title as title4_1_0_, book0_.version as version5_1_0_, book0_.pages as pages6_1_0_, book0_.publisher_id as publishe9_1_0_, publisher2_.name as name2_2_1_ from Publication book0_ inner join Author author1_ on book0_.author_id=author1_.id inner join Publisher publisher2_ on book0_.publisher_id=publisher2_.id where book0_.DTYPE=&#039;Book&#039; and author1_.firstName=?
12:18:05,537 INFO  [org.thoughts.on.java.TestJpaInheritance] - org.thoughts.on.java.model.Book@3458eca5
12:18:05,551 DEBUG [org.hibernate.SQL] - select publicatio0_.id as id2_1_, publicatio0_.author_id as author_i8_1_, publicatio0_.publishingDate as publishi3_1_, publicatio0_.title as title4_1_, publicatio0_.version as version5_1_, publicatio0_.pages as pages6_1_, publicatio0_.publisher_id as publishe9_1_, publicatio0_.url as url7_1_, publicatio0_.DTYPE as dtype1_1_ from Publication publicatio0_ inner join Author author1_ on publicatio0_.author_id=author1_.id where author1_.firstName=?
12:18:05,555 INFO  [org.thoughts.on.java.TestJpaInheritance] - Book - Hibernate Tips - More than 70 solutions to common Hibernate problems was published by Myself
12:18:05,555 INFO  [org.thoughts.on.java.TestJpaInheritance] - org.thoughts.on.java.model.Book@3458eca5
12:18:05,555 INFO  [org.thoughts.on.java.TestJpaInheritance] - BlogPost - Best way to fetch an association defined by a subclass was published at https://thorben-janssen.com/fetch-association-of-subclass/</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>As you can see, Hibernateâ€™s 1st level cache and its guarantee that each Session only uses 1 entity representation for each database record, can be used to create very efficient implementations.</p>



<p>And before you start to worry, this workaround is based on well-documented behaviors and key features of JPA and Hibernate. This is future-proof, and you don&#8217;t need to worry about it when updating your Hibernate dependency.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>