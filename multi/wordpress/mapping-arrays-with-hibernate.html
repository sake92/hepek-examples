<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Mapping Arrays with Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Mapping Arrays with Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Arrays are a common data type in Java and part of the SQL-99 standard. So, it should be easy and quite common to use them with Hibernate, right?</p>



<p>No, they aren’t. Most developers try to avoid using arrays in their persistence layers. There are several reasons for that:</p>



<ul><li>Not all DBMS support arrays. Because of that, Hibernate doesn&#8217;t support native database array types.</li><li>Mappings as a @ElementCollection are not very efficient. Most developers prefer to model a many-to-many or one-to-many association.</li><li>Hibernate can’t offer lazy-loading for the elements of an array. That makes it a bad data type for any associations.</li></ul>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Avoid_it_for_ElementCollection"><span class="toc_number toc_depth_1">1</span> Avoid it for @ElementCollection</a></li><li><a href="#Avoid_it_for_Associations"><span class="toc_number toc_depth_1">2</span> Avoid it for Associations</a></li><li><a href="#Map_it_as_a_BINARY_type"><span class="toc_number toc_depth_1">3</span> Map it as a BINARY type</a></li><li><a href="#Map_it_as_a_Native_Database_Array"><span class="toc_number toc_depth_1">4</span> Map it as a Native Database Array</a><ul><li><a href="#Creating_and_Using_a_UserType"><span class="toc_number toc_depth_2">4.1</span> Creating and Using a UserType</a></li><li><a href="#Searching_in_a_Database_Array"><span class="toc_number toc_depth_2">4.2</span> Searching in a Database Array</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">5</span> Conclusion</a></li></ul></div>
<h2><span id="Avoid_it_for_ElementCollection">Avoid it for <em>@ElementCollection</em></span></h2>



<p><a href="https://thorben-janssen.com/hibernate-tips-query-elementcollection/">I explained @ElementCollection in a previous article</a>, so I keep this part short. The elements of an <em>@ElementCollection</em> get mapped to a separate database table, but they don&#8217;t have a separate lifecycle and identity. They are part of the entity. That makes them easy to use, but it also forces Hibernate to always read and write the <em>@ElementCollection</em> together with all other attributes. This often creates performance issues. </p>



<p>Let&#8217;s take a look at an example of a <em>Book </em>entity. Each <em>Book </em>belongs to 1 or more <em>topics</em>. The names of these topics are modeled as an <em>@ElementCollection</em> of type <em>String[]</em>. In the table model, the topic names get persisted in the <em>book_topics</em> table.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String title;

    @ElementCollection
    @OrderColumn(name = &quot;pos&quot;)
    private String[] topics;
	
    ...
}</pre>



<p>Whenever you fetch a Book entity from the database, Hibernate will need to execute an additional query to get the elements of the <em>String[] topics</em> attributes. And if you change any attribute of a <em>Book </em>entity, Hibernate will remove all of its records from the <em>book_topics </em>table and insert a new record for each element in the <em>topics</em> attribute.</p>



<h2><span id="Avoid_it_for_Associations">Avoid it for Associations</span></h2>



<p>Another mapping you should avoid is the mapping of a to-many association as an array. The main reason for that is that Hibernate doesn’t support lazy loading for it. Because an array has a fixed size, Hibernate has to initialize the association when it instantiates the entity object. That often causes lots of unnecessary database queries and slows down your application.</p>



<p>When mapping the association as a java.util.List or java.util.Set, you can use <em><a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">FetchType.LAZY</a></em> to tell Hibernate not to fetch the association until you use it in your business code. This almost always provides the best performance and avoids <a href="https://thorben-janssen.com/free-n1_select_course/">n+1 select issues</a>.</p>



<h2><span id="Map_it_as_a_BINARY_type">Map it as a BINARY type</span></h2>



<p>OK, let&#8217;s take a look at one of the 2 ways you can efficiently use an array in your mapping. By default, Hibernate maps a Java array of any type to a BINARY type in the database. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String title;

    private String[] topics;
	
    ...
}</pre>



<p>This mapping works well if you only store and read the attribute in your business code. But it provides only minimal support for queries. Because the attribute is mapped as a BINARY type, you can compare the full array that&#8217;s stored in the database field with the value of a bind parameter.</p>



<p>In the example of this article, a book on the topics &#8220;Java Persistence&#8221; and &#8220;Hibernate&#8221; will only get returned by the query if I search for books with exactly these 2 topics.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book b = new Book();
b.setTitle(&quot;Hibernate Tips&quot;);
b.setTopics(new String[]{&quot;Java Persistence&quot;, &quot;Hibernate&quot;});   
em.persist(b);

TypedQuery&lt;Book&gt; q = em.createQuery(&quot;SELECT b FROM Book b WHERE b.topics = :topics&quot;, Book.class);
q.setParameter(&quot;topics&quot;, new String[]{&quot;Java Persistence&quot;, &quot;Hibernate&quot;});
Assert.assertEquals(q.getResultList().size(), 1);</pre>



<p>But if I try to select all books on the topic &#8220;Hibernate&#8221;, the query doesn&#8217;t return any books on multiple topics, even though one of them is &#8220;Hibernate&#8221;.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book b = new Book();
b.setTitle(&quot;Hibernate Tips&quot;);
b.setTopics(new String[]{&quot;Java Persistence&quot;, &quot;Hibernate&quot;});   
em.persist(b);

TypedQuery&lt;Book&gt; q = em.createQuery(&quot;SELECT b FROM Book b WHERE b.topics = :topics&quot;, Book.class);
q.setParameter(&quot;topics&quot;, new String[]{&quot;Hibernate&quot;});
Assert.assertEquals(q.getResultList().size(), 0);</pre>



<p>That makes the mapping as a binary type a bad fit for most applications.</p>



<h2><span id="Map_it_as_a_Native_Database_Array">Map it as a Native Database Array</span></h2>



<p>I wrote at the beginning of this article that Hibernate can&#8217;t map a Java array as a native database array. But you might want to use it anyways because, in contrast to the mapping as a binary type, you can search within a database array. You then need to provide a custom <em>UserType</em> implementation and reference this type in your entity mapping.</p>



<h3><span id="Creating_and_Using_a_UserType">Creating and Using a UserType</span></h3>



<p>The <em>UserType </em>interface might look intimidating because it requires you to implement several methods. But for the typical array types, this isn&#8217;t too complex.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public class PostgreSqlStringArrayType implements UserType {

    @Override
    public int[] sqlTypes() {
        return new int[]{Types.ARRAY};
    }

    @Override
    public Class returnedClass() {
        return String[].class;
    }

    @Override
    public boolean equals(Object x, Object y) throws HibernateException {
        if (x instanceof String[] &amp;&amp; y instanceof String[]) {
            return Arrays.deepEquals((String[])x, (String[])y);
        } else {
            return false;
        }
    }

    @Override
    public int hashCode(Object x) throws HibernateException {
        return Arrays.hashCode((String[])x);
    }

    @Override
    public Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)
            throws HibernateException, SQLException {
        Array array = rs.getArray(names[0]);
        return array != null ? array.getArray() : null;
    }

    @Override
    public void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)
            throws HibernateException, SQLException {
        if (value != null &amp;&amp; st != null) {
            Array array = session.connection().createArrayOf(&quot;text&quot;, (String[])value);
            st.setArray(index, array);
        } else {
            st.setNull(index, sqlTypes()[0]);
        }
    }

    @Override
    public Object deepCopy(Object value) throws HibernateException {
        String[] a = (String[])value;
        return Arrays.copyOf(a, a.length);
    }

    @Override
    public boolean isMutable() {
        return false;
    }

    @Override
    public Serializable disassemble(Object value) throws HibernateException {
        return (Serializable) value;
    }

    @Override
    public Object assemble(Serializable cached, Object owner) throws HibernateException {
        return cached;
    }

    @Override
    public Object replace(Object original, Object target, Object owner) throws HibernateException {
        return original;
    }
    
}</pre>



<p>The most important methods are <em>sqlTypes()</em>, <em>returnedClass()</em>, <em>nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)</em> and <em>nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)</em>.</p>



<p>The first 2 methods return the SQL and the Java type supported by this <em>UserType </em>implementation. </p>



<p>The <em>nullSafeSet </em>method sets your Java array as a native database array on the <em>PreparedStatement</em>. When you implement this method, you have to call the <em>setNull </em>value on your <em>PreparedStatement</em> if the Java array is null.</p>



<p>The <em>nullSafeGet </em>method gets a <em>java.sql.Array</em> object from the <em>ResultSet </em>and retrieves its values as a Java array. Please keep in mind that the database column might contain no value. In that case, the <em>java.sql.Array</em> is <em>null</em>, and you need to handle it accordingly.</p>



<p>After you implemented your <em>UserType</em>, you need to reference it in your entity mapping. You can do that by annotating your entity attribute with Hibernate&#8217;s <em>@Type</em> annotation and setting the fully qualified class name as the value of its <em>type</em> attribute.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String title;

    @Column(columnDefinition = &quot;text[]&quot;)
    @Type(type = &quot;com.thorben.janssen.PostgreSqlStringArrayType&quot;)
    private String[] topics;
	
    ...
}</pre>



<h3><span id="Searching_in_a_Database_Array">Searching in a Database Array</span></h3>



<p>The main benefit of mapping your attribute to a native database array is its additional query capabilities. </p>



<p>Using PostgreSQL and a <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL query</a>, you can use the ANY function in your WHERE clause to retrieve all records containing a specific value as one of the array elements. So, the following query returns all <em>Book </em>entities which have the value &#8220;Hibernate&#8221; as one of the values in the <em>String[] topics</em> attribute.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book b = new Book();
b.setTitle(&quot;Hibernate Tips&quot;);
b.setTopics(new String[]{&quot;Java Persistence&quot;, &quot;Hibernate&quot;});   
em.persist(b);

Query q = em.createNativeQuery(&quot;SELECT * FROM Book b WHERE :topics = ANY(b.topics)&quot;, Book.class);
q.setParameter(&quot;topics&quot;, &quot;Hibernate&quot;);
Assert.assertEquals(q.getResultList().size(), 1);</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>If you want to use a Java array in your domain model, you can choose between the mapping as a binary type and a native database array.</p>



<p>I prefer mapping it as a native database array because it allows you to search within the array. Hibernate doesn’t support this mapping out of the box. You need to provide a custom&nbsp;<em>UserType&nbsp;</em>implementation that tells Hibernate how to handle the Java and the native database array.</p>



<p>After you implemented your&nbsp;<em>UserType</em>, you can use <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL queries</a> to search for specific values within your array</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>