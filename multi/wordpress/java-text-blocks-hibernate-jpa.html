<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Java Text Blocks – Using Multiline Strings with Hibernate &amp; JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Java Text Blocks – Using Multiline Strings with Hibernate &amp; JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>JPA and Hibernate require you to write lots of Strings. You use them to create ad-hoc and named queries with JPQL, to define native SQL queries and to specify the fetching behavior in an EntityGraph. Until Java 13, the lack of multiline Strings in Java made all of these tasks either annoying to implement or the code hard to read. You either had to concatenate multiple Strings or put everything into a single-line String.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">String sql = &quot;SELECT new com.thorben.janssen.BookAuthorReviewCount(b.title, concat(a.firstName, &#039; &#039;, a.lastName), size(b.reviews)) FROM Book b JOIN b.author a GROUP BY b.title, a.firstName, a.lastName&quot;</pre>



<p>That changed drastically with the introduction of <a href="https://openjdk.java.net/jeps/368">Java Text Blocks</a>. You can finally define Strings that span over multiple lines by using 3 quotation marks.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">String sql = &quot;&quot;&quot;
			SELECT new com.thorben.janssen.BookAuthorReviewCount(
							b.title, 
							concat(a.firstName, &#039; &#039;, a.lastName), 
							size(b.reviews)
						) 
			FROM Book b 
				JOIN b.author a 
			GROUP BY b.title, a.firstName, a.lastName
			&quot;&quot;&quot;</pre>



<p>As you can see, that made the SQL statement much easier to read. And because this is a standard Java feature, you can use it everywhere you use a String. But it&#8217;s especially useful if the String is long and complex enough to add linebreaks. Let&#8217;s take a look at a few examples.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Text_blocks_in_JPQL_and_HQL_queries"><span class="toc_number toc_depth_1">1</span> Text blocks in JPQL and HQL queries</a></li><li><a href="#Text_blocks_in_native_SQL_queries"><span class="toc_number toc_depth_1">2</span> Text blocks in native SQL queries</a></li><li><a href="#Text_blocks_to_define_EntityGraphs"><span class="toc_number toc_depth_1">3</span> Text blocks to define EntityGraphs</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="Text_blocks_in_JPQL_and_HQL_queries">Text blocks in JPQL and HQL queries</span></h2>



<p>JPA&#8217;s query language JPQL and the Hibernate-specific extension HQL enable you to write queries based on your entity model. The syntax is very similar to SQL, and I explained it in great detail in <a href="https://thorben-janssen.com/jpql/">my guide to JPQL</a>.</p>



<p>JPQL and HQL are not as powerful as SQL. Nonetheless, you can create pretty complex queries that are hard to read in a single line. </p>



<p>The following query returns BookAuthorReviewCount objects that might be used in a list view in the UI. The query selects the name the author by joining firstName and lastName, the title of the Book, and counts the number of Reviews of each Book.</p>



<p>This query isn&#8217;t easy to read if you write it as a simple, single line String.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;BookAuthorReviewCount&gt; q = em.createQuery(
				&quot;SELECT new com.thorben.janssen.BookAuthorReviewCount(b.title, concat(a.firstName, &#039; &#039;, a.lastName), size(b.reviews)) FROM Book b JOIN b.author a GROUP BY b.title, a.firstName, a.lastName&quot;,
				BookAuthorReviewCount.class);
List&lt;BookAuthorReviewCount&gt; books = q.getResultList();</pre>



<p>Adding a few linebreaks and handling it as a multiline String makes that much easier.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;BookAuthorReviewCount&gt; q = em.createQuery(&quot;&quot;&quot;
				SELECT new com.thorben.janssen.BookAuthorReviewCount(
								b.title, 
								concat(a.firstName, &#039; &#039;, a.lastName), 
								size(b.reviews)
							) 
				FROM Book b 
					JOIN b.author a 
				GROUP BY b.title, a.firstName, a.lastName
				&quot;&quot;&quot;,
				BookAuthorReviewCount.class);
List&lt;BookAuthorReviewCount&gt; books = q.getResultList();</pre>



<p>And the same is true if you create the same query as a named query. You can then use the text block within the @NamedQuery annotation.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@NamedQuery(
	name = &quot;selectBookAuthorReviewCount&quot;, 
	query = &quot;&quot;&quot;
			SELECT new com.thorben.janssen.BookAuthorReviewCount(
							b.title, 
							concat(a.firstName, &#039; &#039;, a.lastName), 
							size(b.reviews)
						) 
			FROM Book b 
				JOIN b.author a 
			GROUP BY b.title, a.firstName, a.lastName
			&quot;&quot;&quot;)
public class Author { ... }</pre>



<h2><span id="Text_blocks_in_native_SQL_queries">Text blocks in native SQL queries</span></h2>



<p>JPA was intentionally designed as a leaky abstraction that enables you to access the underlying JDBC layer. You can use it to write and execute <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL queries</a> that your persistence provider doesn&#8217;t analyze. Using this approach, you can use all query features supported by your database.</p>



<p>I use that in the following SQL statement to select the title of all blog posts and books, the type of publication, and the name of the author. As you can see, books and blog posts are stored in 2 separate tables. I query both tables to get the title together with the type of publication and use a UNION clause to merge the results into one result set. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q = em.createNativeQuery(&quot;&quot;&quot;
				SELECT title, &#039;blog&#039; as type, firstName, lastName
					FROM blogpost JOIN author on author.id = blogpost.author_id
				UNION
				SELECT title, &#039;book&#039; as type, firstName, lastName
					FROM book JOIN author on author.id = book.author_id
				&quot;&quot;&quot;, 
				&quot;PublicationAuthorMapping&quot;);
List&lt;PublicationAuthor&gt; pubs = q.getResultList();
</pre>



<p>That&#8217;s something you can&#8217;t do with JPQL. But you can easily do it using a native SQL statement. And if you combine your native SQL query with an @SqlResultSetMapping, you can get your query result as <a href="https://thorben-janssen.com/result-set-mapping-basics/">entity objects</a>, <a href="https://thorben-janssen.com/result-set-mapping-constructor-result-mappings/">DTO objects</a>, or <a href="https://thorben-janssen.com/result-set-mapping-complex-mappings/">scalar values</a>.</p>



<p>I referenced such a mapping in the previous code snippet to map each record in the result set to a PublicationAuthor object. The required mapping definition is relatively simple. You only need to use a @ConstructorResult annotation, provide the class you want to instantiate as the targetClass, and define an array of @ColumnResult annotations to specify the constructor parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@SqlResultSetMapping(
	name = &quot;PublicationAuthorMapping&quot;, 
	classes = @ConstructorResult(
					targetClass = PublicationAuthor.class, 
					columns = {@ColumnResult(name = &quot;title&quot;),
							   @ColumnResult(name = &quot;type&quot;),
							   @ColumnResult(name = &quot;firstName&quot;),
							   @ColumnResult(name = &quot;lastName&quot;)}))
public class Author { ... }</pre>



<h2><span id="Text_blocks_to_define_EntityGraphs">Text blocks to define EntityGraphs</span></h2>



<p>You can not only use Java text blocks to define your queries. In version 5.4, Hibernate introduced an API to <a href="https://thorben-janssen.com/parse-string-into-entitygraph/">parse a String into an EntityGraph</a>. These Strings describe a hierarchical structure and their readability benefits from multiline Strings.</p>



<p>An <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">EntityGraph</a> tells Hibernate which associations it shall initialize when fetching the result of a query. This is an important performance tuning tool that you need to know when working with Hibernate.</p>



<p>The String used in the following example gets parsed into an EntityGraph that tells Hibernate to fetch the book and blogPost associations defined on the Author entity. For the book association, it will also fetch the associated publisher and the editor who worked on the book.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">RootGraph graph = GraphParser.parse(Author.class, 
									&quot;&quot;&quot;
									blogPosts, 
									books(publisher(editor))&quot;&quot;&quot;, 
									em);

TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class);
q.setHint(GraphSemantic.FETCH.getJpaHintName(), graph);
List&lt;Author&gt; authors = q.getResultList();</pre>



<p>If you&#8217;re using such an EntityGraph, Java&#8217;s text block feature can improve the readability of your code. But you also need to doublecheck your query and analyze if fetching that many associations makes your query too complex. Depending on the number of elements in each association, it might be better to <a href="https://thorben-janssen.com/fix-multiplebagfetchexception-hibernate/">split this query into multiple ones</a>.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p> Java&#8217;s text blocks might look like a small feature, but they can improve the readability of your code a lot. </p>



<p>Because it&#8217;s a standard Java feature, you can use it everywhere in your code. But not all places will benefit the same. Text blocks are especially useful if the created String naturally contains linebreaks or gets easier to read if you split it over multiple lines. </p>



<p>With JPA and Hibernate, you create a lot of Strings that belong in the 2nd category. Especially queries get often long and complex. Spreading them over multiple lines allows you to structure them visually and to improve their readability. I&#8217;m sure that it won&#8217;t take long until everyone uses Java text blocks to write their queries.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>