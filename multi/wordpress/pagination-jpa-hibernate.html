<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Pagination with JPA and Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Pagination with JPA and Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>The size of a result set has a huge impact on the performance of a query, the burden it puts on your Java application, and the user experience your UI provides. It&#8217;s a general best practice to split huge result sets into multiple parts presented on separate pages. This process is called pagination.</p>



<p>The most common way to implement pagination using a relational database is to add a LIMIT and OFFSET clause to the SQL query. The LIMIT defines the maximum number of records that shall be returned. The OFFSET clause specifies how many records shall be skipped before the first record gets returned. As long as you ensure a stable ordering of the result set, you can use these 2 clauses to scroll through the result set.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Pagination_With_Hibernate_and_JPA"><span class="toc_number toc_depth_1">1</span> Pagination With Hibernate and JPA</a><ul><li><a href="#Paginating_a_Native_SQL_Query"><span class="toc_number toc_depth_2">1.1</span> Paginating a Native SQL Query</a></li><li><a href="#Paginating_a_JPQL_Query"><span class="toc_number toc_depth_2">1.2</span> Paginating a JPQL Query</a></li><li><a href="#Paginating_a_CriteriaQuery"><span class="toc_number toc_depth_2">1.3</span> Paginating a CriteriaQuery</a></li></ul></li><li><a href="#Pitfalls_When_Using_Pagination"><span class="toc_number toc_depth_1">2</span> Pitfalls When Using Pagination</a><ul><li><a href="#Pitfall_1_Pagination_Requires_a_Stable_Order"><span class="toc_number toc_depth_2">2.1</span> Pitfall 1: Pagination Requires a Stable Order</a></li><li><a href="#Pitfall_2_Pagination_With_JOIN_FETCH_and_EntityGraphs_Clauses"><span class="toc_number toc_depth_2">2.2</span> Pitfall 2: Pagination With JOIN FETCH and EntityGraphs Clauses</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="Pagination_With_Hibernate_and_JPA">Pagination With Hibernate and JPA</span></h2>



<p>You can, of course, use pagination with JPA and Hibernate. The easiest way to do that is to add the LIMIT and OFFSET clauses to a <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL query</a>. <a href="https://thorben-janssen.com/jpql/">JPQL</a> and the Criteria API don&#8217;t support these 2 clauses as part of the query. But they provide an API to set them. Hibernate will then add the required clauses to the generated SQL statement.</p>



<h3><span id="Paginating_a_Native_SQL_Query">Paginating a Native SQL Query</span></h3>



<p>JPA and Hibernate are designed as a leaky abstraction and enable you to execute any SQL query supported by your database. You only need to call the&nbsp;<em>createNativeQuery&nbsp;</em>method on your&nbsp;<em>EntityManager&nbsp;</em>with an SQL statement. That enables you to use database-specific features, like <a href="https://thorben-janssen.com/persist-postgresqls-jsonb-data-type-hibernate/">PostgreSQL&#8217;s JSON support</a>. You can also <a href="https://thorben-janssen.com/use-native-queries-perform-bulk-updates/">execute SQL UPDATE statements</a> or SELECT statements with a LIMIT and OFFSET clause.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query query = em.createNativeQuery(&quot;SELECT * FROM author a ORDER a.id LIMIT 5 OFFSET 5&quot;, Author.class);
List&lt;Author&gt; authors = query.getResultList();
</pre>



<p>If you provide an entity class as the 2nd parameter to the <em>createNativeQuery </em>method, every record of the result set gets automatically <a href="https://thorben-janssen.com/result-set-mapping-basics/">mapped to an entity object</a>. If you want to use a different mapping, e.g., to a DTO class, you can <a href="https://thorben-janssen.com/result-set-mapping-constructor-result-mappings/">reference an <em>@SqlResultSetMapping</em> instead</a>.</p>



<p>The downside of this approach is that every DBMS supports a slightly different SQL dialect. Hibernate doesn&#8217;t change the provided SQL statement. It only sends it to the database. You, therefore, need to make sure that you use the right dialect for your DBMS. This can be problematic if you need to deploy your application using multiple DBMS.</p>



<p>You can avoid this by using the <em>setFirstResult</em> and <em>setMaxResults</em> method on the <em>Query </em>interface. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query query = em.createNativeQuery(&quot;SELECT * FROM author a ORDER a.id&quot;, Author.class);
List&lt;Author&gt; authors = query.setFirstResult(5)
							.setMaxResults(5)
							.getResultList();</pre>



<p>Hibernate then uses the database dialect to generate the required SQL clauses. For a PostgreSQL database, these are an OFFSET clause with the value provided to the <em>setFirstResult </em>method and a LIMIT clause with the value supplied to the <em>setMaxResults </em>method.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">SELECT
	* 
FROM
	author a 
ORDER BY
	a.id  limit ? offset ?</pre>



<h3><span id="Paginating_a_JPQL_Query">Paginating a JPQL Query</span></h3>



<p>As mentioned earlier, <a href="https://thorben-janssen.com/jpql/">JPQL</a> doesn&#8217;t support LIMIT and OFFSET clauses. But you can use the same <em>setFirstResult </em>and <em>setMaxResults </em>methods of the <em>Query </em>and <em>TypedQuery </em>interface that I showed you in the previous section.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Author&gt; query = em.createQuery(&quot;SELECT a  FROM Author a order by a.id asc&quot;, Author.class);
List&lt;Author&gt; authors = query.setFirstResult(5)
							.setMaxResults(5)
							.getResultList();
</pre>



<p>Hibernate then uses the configured dialect to add the required SQL clauses to the generated statement. For a PostgreSQL database, these are the LIMIT and an OFFSET clause you can see in the following snippet.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.id as id1_0_,
	author0_.firstName as firstnam2_0_,
	author0_.lastName as lastname3_0_,
	author0_.version as version4_0_ 
from
	Author author0_ 
order by author0_.id asc 
limit ? offset ?
</pre>



<h3><span id="Paginating_a_CriteriaQuery">Paginating a CriteriaQuery</span></h3>



<p>When you execute a <em>CriteriaQuery</em>, you instantiate the same <em>Query</em> or <em>TypedQuery</em> interfaces as you use for a JPQL query. Because of that, you can use the already explained <em>setFirstResult</em> and <em>setMaxResult </em>methods to add pagination to your <em>CriteriaQuery</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery&lt;Author&gt; cq = cb.createQuery(Author.class);
Root&lt;Author&gt; root = cq.from(Author.class);
cq.orderBy(cb.asc(root.get(&quot;id&quot;)));

TypedQuery&lt;Author&gt; query = em.createQuery(cq);
List&lt;Author&gt; authors = query.setFirstResult(5)
							.setMaxResults(5)
							.getResultList();
</pre>



<p>Hibernate then uses the configured dialect to generate the required clauses and adds them to the SQL statement.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.id as id1_0_,
	author0_.firstName as firstnam2_0_,
	author0_.lastName as lastname3_0_,
	author0_.version as version4_0_ 
from
	Author author0_ 
order by author0_.id asc 
limit ? offset ?</pre>



<h2><span id="Pitfalls_When_Using_Pagination">Pitfalls When Using Pagination</span></h2>



<p>As you have seen, using pagination with Hibernate and JPA is simple. But there are a few pitfalls you need to be aware of.</p>



<h3><span id="Pitfall_1_Pagination_Requires_a_Stable_Order">Pitfall 1: Pagination Requires a Stable Order</span></h3>



<p>By calling the <em>setFirstResult </em>and <em>setMaxResults</em> methods on your <em>Query </em>interface, you tell the database the index of the first and the last record of the result set it shall return. If you want to scroll through the entire result set, you need to execute the query multiple times and provide different values to the <em>setFirstResult </em>and <em>setMaxResults </em>methods.</p>



<p>To ensure that this approach works as expected, you also need to ensure that the query always returns the result in the same order. This is only the case if your query contains an ORDER BY clause. Otherwise, the order of the result set is undefined and might change.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Author&gt; query = em.createQuery(&quot;SELECT a  FROM Author a order by a.id asc&quot;, Author.class);
List&lt;Author&gt; authors = query.setFirstResult(5)
							.setMaxResults(5)
							.getResultList();
</pre>



<h3><span id="Pitfall_2_Pagination_With_JOIN_FETCH_and_EntityGraphs_Clauses">Pitfall 2: Pagination With JOIN FETCH and EntityGraphs Clauses</span></h3>



<p>If your query returns entity objects, you can use an <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">EntityGraph</a> or a JOIN FETCH clause to specify the <a href="https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/">associations that shall get initialized</a>. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Author&gt; query = em.createQuery(&quot;SELECT a FROM Author a LEFT JOIN fetch a.books ORDER BY a.id&quot;, Author.class);</pre>



<p>This, of course, affects the generated SQL statement. Hibernate needs to add a JOIN clause for each of the retrieved associations, which increases the size of the result set.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	distinct author0_.id as id1_0_0_,
	books1_.id as id1_1_1_,
	author0_.firstName as firstnam2_0_0_,
	author0_.lastName as lastname3_0_0_,
	author0_.version as version4_0_0_,
	books1_.author_id as author_i4_1_1_,
	books1_.title as title2_1_1_,
	books1_.version as version3_1_1_,
	books1_.author_id as author_i4_1_0__,
	books1_.id as id1_1_0__ 
from
	Author author0_ 
left outer join
	Book books1_ 
		on author0_.id=books1_.author_id 
order by
	author0_.id
</pre>



<p>When you add pagination to this query, you will see the following warning in the log file.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">WARN: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!
Hibernate: 
    select
        distinct author0_.id as id1_0_0_,
        books1_.id as id1_1_1_,
        author0_.firstName as firstnam2_0_0_,
        author0_.lastName as lastname3_0_0_,
        author0_.version as version4_0_0_,
        books1_.author_id as author_i4_1_1_,
        books1_.title as title2_1_1_,
        books1_.version as version3_1_1_,
        books1_.author_id as author_i4_1_0__,
        books1_.id as id1_1_0__ 
    from
        Author author0_ 
    left outer join
        Book books1_ 
</pre>



<p>The fetched associations increase the size of the result set. If Hibernate would apply pagination to this query, it would no longer return the expected result. Because of that, Hibernate has to retrieve all records of the result set and apply the pagination in memory. </p>



<p>You can avoid this problem by splitting your query into 2. The first one uses pagination to get a list of the records&#8217; primary keys that match your search criteria. You can then use this list in the second query to retrieve the entities with their initialized associations.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">// Get primary keys with LIMIT and OFFSET
TypedQuery&lt;Long&gt; idQuery = em.createQuery(&quot;SELECT a.id FROM Author a order by a.id&quot;, Long.class);
List&lt;Long&gt; authorIds = idQuery.setFirstResult(5)
							  .setMaxResults(5)
							  .getResultList();
							  
// Get entities with associations
TypedQuery&lt;Author&gt; authorQuery = em.createQuery(&quot;SELECT DISTINCT a FROM Author a LEFT JOIN FETCH a.books WHERE a.id in (:ids)&quot;, Author.class);
authorQuery.setParameter(&quot;ids&quot;, authorIds);
List&lt;Author&gt; authors = authorQuery.getResultList();</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Pagination is a simple but important feature to limit the size of your result set to a number of records that can get efficiently processed by your application and the user. You can configure it with JPA and Hibernate by calling the <em>setFirstResult </em>and <em>setMaxResults </em>on the <em>Query </em>or <em>TypedQuery </em>interface.</p>



<p>When you use pagination, you need to add an ORDER BY clause, and you should try to avoid it when using JOIN FETCH clauses or an EntityGraph.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>