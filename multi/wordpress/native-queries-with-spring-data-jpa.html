<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Native Queries with Spring Data JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Native Queries with Spring Data JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Spring Data JPA supports various ways to retrieve data from your database. Some are very easy to use, like <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derived queries</a>. Others provide great flexibility and enable you to read and transform the data in various ways, e.g., <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">custom queries</a>. Native queries are the extreme of the 2nd category. They are your most flexible and most powerful option to read data.</p>



<p>As I explained in a previous post about <a href="https://thorben-janssen.com/jpa-native-queries/">native queries in JPA</a>, they provide you access to all features supported by your database. That makes them an excellent fit for all use cases that require a complex query to extract the required information. The same is true, of course, if you&#8217;re using native queries with Spring Data JPA because you&#8217;re using the same mechanism internally. Spring Data JPA just makes the definition and execution of a native query a little easier.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Defining_a_Native_Query"><span class="toc_number toc_depth_1">1</span> Defining a Native Query</a><ul><li><a href="#Write_Operations_as_Native_Queries"><span class="toc_number toc_depth_2">1.1</span> Write Operations as Native Queries</a></li></ul></li><li><a href="#Limitations_of_Native_Queries_With_Spring_Data_JPA"><span class="toc_number toc_depth_1">2</span> Limitations of Native Queries With Spring Data JPA</a><ul><li><a href="#Add_a_Count_Query_to_Enable_Pagination"><span class="toc_number toc_depth_2">2.1</span> Add a Count Query to Enable Pagination</a></li><li><a href="#No_Dynamic_Sorting"><span class="toc_number toc_depth_2">2.2</span> No Dynamic Sorting</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="Defining_a_Native_Query">Defining a Native Query</span></h2>



<p>When using plain JPA or Hibernate, defining and executing a native query requires multiple steps. Spring Data&#8217;s <em>@Query</em> annotation removes all the boilerplate code. We already used that annotation in a previous post to <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">define a custom JPQL query</a>.</p>



<p>When defining a native query, you annotate your repository method with <em>@Query</em>, set its <em>nativeQuery</em> attribute to <em>true</em>, and provide an SQL statement as the <em>value</em>. As shown in the following code snippet, you can use bind parameters in the same way as in a custom JPQL query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt;, PagingAndSortingRepository&lt;Author, Long&gt; {

	@Query(value=&quot;select * from author a where a.first_name= :firstName&quot;, nativeQuery=true)
	List&lt;Author&gt; getAuthorsByFirstName(String firstName);


}</pre>



<p>After you&#8217;ve done that, you only need to inject your repository into one of your services and call the <em>getAuthorsByFirstName</em> method with the <em>firstName </em>for which you want to search.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">List&lt;Author&gt; authors = authorRepository.getAuthorsByFirstName(&quot;Janssen&quot;);</pre>



<p>Spring Data&#8217;s repository implementation then provides the required code to instantiate a query for the statement provided in your <em>@Query</em> annotation. It then sets the provided value as a bind parameter on that query and executes it.</p>



<h3><span id="Write_Operations_as_Native_Queries">Write Operations as Native Queries</span></h3>



<p>As I explain in great detail in my Hibernate Performance Tuning Online Training, bulk operations are often the better option to change or remove a huge number of database records. You can implement these operations using JPQL, <a href="https://thorben-janssen.com/criteria-updatedelete-easy-way-to/">Criteria</a>, or <a href="https://thorben-janssen.com/use-native-queries-perform-bulk-updates/">native queries</a>.</p>



<p>You can use the <em>@Query</em> annotation to define such a JPQL or native SQL statement. Because write operations need to be executed differently than read operations, you also need to annotate the repository method with a <em>@Modifying</em> annotation. That&#8217;s the only difference to the previously discussed native SQL SELECT statements.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt;, PagingAndSortingRepository&lt;Author, Long&gt; {

	@Modifying
	@Query(value=&quot;delete from author a where a.last_name= :lastName&quot;, nativeQuery = true)
	void deleteAuthorByLastName(@Param(&quot;lastName&quot;) String lastName);
	
	@Modifying
	@Query(value=&quot;update author set last_name= :lastName where first_name = :firstName&quot;, nativeQuery=true)
	void updateAuthorByFirstName(String firstName, String lastName);
	
	...
}
</pre>



<h2><span id="Limitations_of_Native_Queries_With_Spring_Data_JPA">Limitations of Native Queries With Spring Data JPA</span></h2>



<p>When using native queries, you need to be aware of 2 limitations:</p>



<ol><li>Spring Data JPA and your persistence provider don&#8217;t adjust the query to your database&#8217;s specific SQL dialect. Because of that, you need to ensure that all RDBMS supported by your application can handle the provided statement.</li><li>Pagination of native query results requires an extra step.</li><li>Spring Data JPA doesn&#8217;t support dynamic sorting for native SQL statements. </li></ol>



<p>Let&#8217;s take a closer look at the 2nd and 3rd limitation.</p>



<h3><span id="Add_a_Count_Query_to_Enable_Pagination">Add a Count Query to Enable Pagination</span></h3>



<p>When working with a custom JPQL query, you can add a parameter of type <em>Pageable </em>to your repository method. This enables pagination for your query result. Spring Data JPA then adds all the required boilerplate code to retrieve the query result one page at a time.</p>



<p>Doing the same with a native query requires an extra step. You need to provide a count query that returns the total number of records included in the non-paged result. One way to do that is to provide the query <em>String </em>as the value of the <em>countQuery </em>attribute of the <em>@Query</em> annotation.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Repository
public interface AuthorRepository extends CrudRepository&lt;Author, Long&gt;, PagingAndSortingRepository&lt;Author, Long&gt; {
    
	@Query(value=&quot;select * from author a where a.last_name= ?1&quot;, 
			countQuery = &quot;select count(id) from author a where a.last_name= ?1&quot;, 
			nativeQuery = true)
	Page&lt;Author&gt; getAuthorsByLastName(String lastname, Pageable page);
	
	...
}</pre>



<p>If your <a href="https://thorben-janssen.com/spring-data-jpa-named-queries/">repository method references a named native query</a>, you need to provide the count query as a 2nd named query and add the suffix <em>.count</em> to its name.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@NamedNativeQuery(name = &quot;Author.getAuthorsByLastName&quot;, 
                    query = &quot;select * from author a where a.last_name= ?1&quot;, 
                    resultClass = Author.class)
@NamedNativeQuery(name = &quot;Author.getAuthorsByLastName.count&quot;, 
                    query = &quot;select count(id) from author a where a.last_name= ?1&quot;)
@Entity
public class Author { ... }</pre>



<h3><span id="No_Dynamic_Sorting">No Dynamic Sorting</span></h3>



<p>When working with a JPQL query, you can add a parameter of type <em>Sort</em> to your repository method. This enables you to define the sorting criteria at runtime. Spring Data JPA then generates the required ORDER BY clause based on the provided parameter value.</p>



<p>Unfortunately, Spring Data JPA doesn&#8217;t support this feature for native queries. Doing that would require Spring Data to analyze the provided statement and generate the ORDER BY clause in the database-specific dialect. This would be a very complex operation and is currently not supported by Spring Data JPA.</p>



<p>You can, of course, add your own ORDER BY clause to your query. But that limits you to one specific ordering per query. If you need to support multiple ones, using a <a href="https://thorben-janssen.com/composite-repositories-spring-data-jpa/">composite repository</a> is often the better approach. You can then implement your own query method using JPA&#8217;s Criteria API and specify the ORDER BY clause based on the provided input parameters.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Native queries are the most powerful and flexible way to implement your read operations. They enable you to use all features supported by your database, and Spring Data JPA handles almost all of the required boilerplate code. </p>



<p>But using them takes more effort than a <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derived query</a>, and they provide a few limitations compared to a <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">custom JPQL query</a>. The most notable ones are:</p>



<ol><li>To use pagination for your query result, you need to provide a count query. You can do that by setting the <em>countQuery </em>attribute of the <em>@Query</em> annotation.</li><li>Spring Data JPA doesn&#8217;t support dynamic sorting for native queries. If you want to retrieve your query result in a specific order, you need to include the ORDER BY clause in your query.</li><li>Spring Data JPA and your persistence provider don&#8217;t adjust your native query statement to your database&#8217;s SQL dialect. Because of that, you need to ensure that all of your supported DBMS support your SQL statement.</li></ol></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>