<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Modeling self-referencing associations with Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Modeling self-referencing associations with Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>When you model a hierarchical data structure, you often have to use self-referencing associations. Both ends of these associations are of the same type. In other words, the entity object on which the association is defined and the one the association references are of the same type. In your database, you model that using a foreign key column that references the same table&#8217;s <a href="https://thorben-janssen.com/primary-key-mappings-jpa-hibernate/">primary key</a>.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Example_Mappings"><span class="toc_number toc_depth_1">1</span> Example Mappings</a></li><li><a href="#Common_Pitfalls_of_Self-Referencing_Associations"><span class="toc_number toc_depth_1">2</span> Common Pitfalls of Self-Referencing Associations</a></li><li><a href="#Pitfall_1_Managing_associations"><span class="toc_number toc_depth_1">3</span> Pitfall 1: Managing associations</a><ul><li><a href="#Example_1_Add_a_new_Parent-Child_Association"><span class="toc_number toc_depth_2">3.1</span> Example 1: Add a new Parent-Child Association</a></li><li><a href="#Example_2_Add_a_new_Sub-Category"><span class="toc_number toc_depth_2">3.2</span> Example 2: Add a new Sub-Category</a></li></ul></li><li><a href="#Pitfall_2_Fetching_behavior"><span class="toc_number toc_depth_1">4</span> Pitfall 2: Fetching behavior</a><ul><li><a href="#Example_Default_FetchType_of_a_to-one_association"><span class="toc_number toc_depth_2">4.1</span> Example: Default FetchType of a to-one association</a></li></ul></li><li><a href="#Pitfall_3_Performing_Queries_on_Your_Entity_Hierarchy"><span class="toc_number toc_depth_1">5</span> Pitfall 3: Performing Queries on Your Entity Hierarchy</a><ul><li><a href="#Initializing_Self-Referencing_Associations"><span class="toc_number toc_depth_2">5.1</span> Initializing Self-Referencing Associations</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">6</span> Conclusion</a></li></ul></div>
<h2><span id="Example_Mappings">Example Mappings</span></h2>



<p>A typical example is a <em>Person</em> who has other <em>Person</em>s as their parents. You can model it as a uni- or bidirectional <a href="/ultimate-guide-association-mappings-jpa-hibernate/#manyToMany">many-to-many association</a> on the <em>Person</em> entity. </p>



<p>In the following code snippet, the <em>parents </em>and the <em>children </em>attribute model both ends of a <a href="/ultimate-guide-association-mappings-jpa-hibernate/#biManyToMany">bidirectional many-to-many mapping</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Person {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String firstName;

    private String lastName;

    @ManyToMany
    private Set&lt;Person&gt; parents = new HashSet&lt;&gt;();

    @ManyToMany(mappedBy = &quot;parents&quot;)
    private Set&lt;Person&gt; children = new HashSet&lt;&gt;();

    ...
}</pre>



<p>Another example is a <em>Category</em> that is a subcategory of another <em>Category</em>. You can model that as a uni- or bidirectional <a href="/ultimate-guide-association-mappings-jpa-hibernate/#manyToOne">many-to-one/one-to-many association</a>. </p>



<p>The <em>parentCategory </em>and <em>subCategories </em>attributes of the following <em>Category </em>entity map it as a <a href="/ultimate-guide-association-mappings-jpa-hibernate/#biManyToOne">bidirectional association</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Category {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    private Category parentCategory;

    @OneToMany(mappedBy = &quot;parentCategory&quot;)
    private Set&lt;Category&gt; subCategories = new HashSet&lt;&gt;();
	
    ...
}</pre>



<p>During your requirements analysis, these kinds of associations often seem to be very simple. But when you implement your mappings and business code, you quickly recognize that these mappings introduce several pitfalls.</p>



<h2><span id="Common_Pitfalls_of_Self-Referencing_Associations">Common Pitfalls of Self-Referencing Associations</span></h2>



<p>In this article, I want to show you the most common of these pitfalls. You can avoid most of them relatively easily in your application. But for others, you might want to consider using a totally different approach, e.g., a graph database.</p>



<h2><span id="Pitfall_1_Managing_associations">Pitfall 1: Managing associations</span></h2>



<p>As for all association mappings, you need to decide if you want to map it uni- or bidirectionally. A unidirectional mapping only models the association in one direction, e.g., from a child to their parents. A bidirectional mapping would also model the association from each parent to their children.</p>



<p>In general, unidirectional associations are easier to update. Bidirectional associations are easier to use in your queries and business code. For most applications, the number and complexity of read operations are a lot higher than for write operations. Because of that, a lot of developers prefer bidirectional mappings.</p>



<p>If you decide to use a bidirectional mapping, you always need to update both ends of your association. Otherwise, Hibernate might not persist your change in the database, and the entities in your current persistence context become outdated.</p>



<p>The best way to do that for a self-referencing association is to provide <a href="/best-practices-for-many-to-many-associations-with-hibernate-and-jpa/#Why_you_need_utility_methods_to_manage_your_association">utility methods</a>. Their names should represent the actual business operation and perform all necessary validations.</p>



<h3><span id="Example_1_Add_a_new_Parent-Child_Association">Example 1: Add a new Parent-Child Association</span></h3>



<p>For the <em>Person </em>example in this article, that might be the method <em>addParents(Person parent1, Person parent2)</em>. It adds the 2 provided <em>Person </em>objects to the <em>parents </em>association of a <em>Person</em>. Within that method, you could also check that there are no <em>parents</em> set for that <em>Person </em>and update the associations on all 3 <em>Person </em>objects.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Person {

    ...
	
    public void addParents(Person parent1, Person parent2) {
        if (!this.parents.isEmpty()) {
            throw new IllegalArgumentException();
        }

        this.parents.add(parent1);
        parent1.getChildren().add(this);
        this.parents.add(parent2);
        parent2.getChildren().add(this);
    }
}</pre>



<p>Or you could provide the method <em>createChild(String firstName, String lastName, Person parent2)</em>. This method instantiates a new <em>Person </em>object using the provided <em>firstName </em>and <em>lastName</em>, adds it to the <em>Set</em> of <em>children</em>, and initializes the <em>parents </em>association on the newly created <em>Person</em> object.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Person {

    ...
	
    public Person createChild(String firstName, String lastName, Person parent2) {
        Person child = new Person();
        child.setFirstName(firstName);
        child.setLastName(lastName);
        this.children.add(child);
        child.getParents().add(this);

        if (parent2 != null) {
            parent2.getChildren().add(child);
            child.getParents().add(parent2);
        }
        return child;
    }
}</pre>



<h3><span id="Example_2_Add_a_new_Sub-Category">Example 2: Add a new Sub-Category</span></h3>



<p>In the category example, the implementation of an <em>addSubCategory(String categoryName)</em> or a <em>moveCategory(Category newParent)</em> method would require a different association handling. </p>



<p>The implementation of the <em>addSubCategory(String categoryName)</em> method would be straight forward. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Category {

    ...
    
    public Category addSubCategory(String categoryName) {
        Category sub = new Category();
        sub.setName(categoryName);
        this.subCategories.add(sub);
        sub.setParentCategory(this);
        return sub;
    }
}</pre>



<p>You instantiate a new <em>Category </em>object, add it to the <em>subCategory </em>list of the <em>Category </em>object on which you called the method, and set that object as the parent of the newly created <em>Category</em>.</p>



<p>Moving a category requires an extra step that gets often forgotten.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Category {

    ...
    
    public void moveCategory(Category newParent) {
        this.getParentCategory().getSubCategories().remove(this);
        this.setParentCategory(newParent);
        newParent.getSubCategories().add(this);
    }
}</pre>



<p>You not only need to add the <em>Category</em> object to the <em>subCategories</em> <em>Set</em> of the parent and update the <em>parentCategory</em> reference on your sub-category object. You also need to remove the sub-category object from the <em>subCategories</em> list of the old parent <em>Category</em>.</p>



<h2><span id="Pitfall_2_Fetching_behavior">Pitfall 2: Fetching behavior</span></h2>



<p>Choosing the wrong <em><a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">FetchType</a> </em>for your associations is always a huge performance risk. That&#8217;s especially the case for self-referencing associations. Picking the wrong <em>FetchType </em>affects not only a single association in your domain model, but also your entire entity hierarchy.</p>



<p>You should always use <em><a href="/entity-mappings-introduction-jpa-fetchtypes/#FetchTypeLAZY_8211Fetch_it_when_you_need_it">FetchType.LAZY</a></em> for all of your associations. This is the default for all to-many associations, and you need to declare it all of your to-one associations.</p>



<h3><span id="Example_Default_FetchType_of_a_to-one_association">Example: Default <em>FetchType </em>of a to-one association</span></h3>



<p>Let&#8217;s use the category example to see the effect of a missing <em>FetchType </em>declaration for a to-one association. The following mapping uses the default <em><a href="/entity-mappings-introduction-jpa-fetchtypes/#FetchTypeEAGER_8211_Fetch_it_so_you8217ll_have_it_when_you_need_it">FetchType.EAGER</a></em> for the <em>parent </em>association. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Category {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String name;

    @ManyToOne
    private Category parentCategory;

    @OneToMany(mappedBy = &quot;parentCategory&quot;)
    private Set&lt;Category&gt; subCategories = new HashSet&lt;&gt;();
	
    ...
}</pre>



<p>If you load this entity from the database, Hibernate will initialize the association to the <em>parent </em>entity. When it instantiates the <em>Category </em>object for the <em>parent</em>, it also has to initialize its <em>parent </em>association. This process continues until you reach the top of the hierarchy, where the <em>parent </em>attribute is <em>null</em>. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">Category cat = em.find(Category.class, 103L);</pre>



<p>Depending on your approach to load the <em>Category </em>entity, Hibernate might optimize this approach and join a <em>Category </em>with its immediate <em>parent </em>in 1 query.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">16:37:56,607 DEBUG [org.hibernate.SQL] - 
    select
        category0_.id as id1_0_0_,
        category0_.name as name2_0_0_,
        category0_.parentCategory_id as parentca3_0_0_,
        category1_.id as id1_0_1_,
        category1_.name as name2_0_1_,
        category1_.parentCategory_id as parentca3_0_1_ 
    from
        Category category0_ 
    left outer join
        Category category1_ 
            on category0_.parentCategory_id=category1_.id 
    where
        category0_.id=?
16:37:56,627 DEBUG [org.hibernate.SQL] - 
    select
        category0_.id as id1_0_0_,
        category0_.name as name2_0_0_,
        category0_.parentCategory_id as parentca3_0_0_,
        category1_.id as id1_0_1_,
        category1_.name as name2_0_1_,
        category1_.parentCategory_id as parentca3_0_1_ 
    from
        Category category0_ 
    left outer join
        Category category1_ 
            on category0_.parentCategory_id=category1_.id 
    where
        category0_.id=?</pre>



<p>But this still forces Hibernate to execute multiple queries to fetch all levels of the hierarchy. So, better double-check all your association mappings and make sure you&#8217;re not using eager fetching.</p>



<h2><span id="Pitfall_3_Performing_Queries_on_Your_Entity_Hierarchy">Pitfall 3: Performing Queries on Your Entity Hierarchy</span></h2>



<p>You can easily define a query that joins over 2-3 levels of your hierarchy. There is no difference between a join over a self-referencing and any other association. As long as you make sure to provide an index for your foreign key column, your database usually handles these queries easily.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Category&gt; q = em.createQuery(
	&quot;SELECT c &quot;
	+&quot;FROM Category c &quot;
		+&quot;JOIN c.parentCategory p &quot;
		+&quot;JOIN p.parentCategory pp &quot;
	+&quot;WHERE c.name = :name &quot;
		+&quot;OR p.name = :name &quot;
		+&quot;OR pp.name = :name &quot;,
	Category.class);
q.setParameter(&quot;name&quot;, &quot;myCategory&quot;);
q.getSingleResult();</pre>



<p>But for quite a few applications, this isn’t good enough. You often need to search all levels of your hierarchy. Depending on the application’s domain, this can be less than 5 or several hundred. If your application requires JOINs over a huge number of hierarchy levels, you might consider using a graph database. They have been specially developed for these kinds of use cases. Relational databases and SQL are not well suited for that.</p>



<h3><span id="Initializing_Self-Referencing_Associations">Initializing Self-Referencing Associations</span></h3>



<p>JOIN FETCH clauses and <em><a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">EntityGraphs</a></em> enable you to avoid <a href="https://thorben-janssen.com/free-n1_select_course/">n+1 select issues</a> and to initialize your association efficiently. This also works for self-referencing associations.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Category&gt; q = em.createQuery(
	&quot;SELECT c &quot;
	+&quot;FROM Category c &quot;
		+&quot;JOIN FETCH c.parentCategory p &quot;
		+&quot;JOIN FETCH p.parentCategory &quot;
	+&quot;WHERE c.id = :id&quot;,
	Category.class);
q.setParameter(&quot;id&quot;, 103L);
q.getSingleResult();</pre>



<p>But you should be aware of an issue that I see very often in my consulting projects: If you use multiple JOIN FETCH clauses or complex EntityGraphs, your SQL query returns a huge product. This often slows down your application.</p>



<p>A lot of developers are aware of that but ignore it for self-referencing associations. That&#8217;s dangerous because you will experience the same performance issues as with any query that join fetches multiple associations. To fix that problem, you need to split your query into multiple ones, as I explained in a <a href="https://thorben-janssen.com/lazyinitializationexception/">previous article</a>.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>There is not a huge difference between a self-referencing association and an association that references another entity class. But you should pay special attention to:</p>



<ul><li>The <em><a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">FetchType </a></em>of your association, because it might force Hibernate to fetch the entire hierarchy,</li><li>Provide utility methods to <a href="/best-practices-for-many-to-many-associations-with-hibernate-and-jpa/#Why_you_need_utility_methods_to_manage_your_association">make managing bidirectional associations easier</a> and</li><li>Not join over too many levels of your hierarchy.</li></ul></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>