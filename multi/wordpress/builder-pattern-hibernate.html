<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>The Builder Pattern – How to use it with Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>The Builder Pattern – How to use it with Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>When I shared last week&#8217;s article about implementing the <a href="https://thorben-janssen.com/fluent-entities-with-hibernate-and-jpa/">fluent interface</a> pattern on twitter, I got asked about using the builder pattern for your entities.</p>



<figure class="wp-block-embed-twitter wp-block-embed is-type-rich is-provider-twitter"><div class="wp-block-embed__wrapper">
<span class="t63GUVho0aFpwOub7Wjc91sB5DryCL2zNgTm8nRYJXIPEQZK4elHAfivMq"><blockquote class="twitter-tweet" data-width="500" data-dnt="true"><p lang="en" dir="ltr">How about using <a href="https://twitter.com/hashtag/BuilderPattern?src=hash&amp;ref_src=twsrc%5Etfw">#BuilderPattern</a> for <a href="https://twitter.com/hashtag/jpa?src=hash&amp;ref_src=twsrc%5Etfw">#jpa</a> entities, is it advisable?</p>&mdash; bhavik patel (@bhavikcpatel) <a href="https://twitter.com/bhavikcpatel/status/1163429793616060417?ref_src=twsrc%5Etfw">August 19, 2019</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></span>
</div></figure>



<p>Implementing the builder pattern for your entities can massively improve the readability of your business code.</p>



<p>In contrast to the fluent interface pattern, there is nothing in the JPA specification or the Hibernate documentation that prevents you from implementing a builder for an entity class. </p>



<p>But implementing a good builder for your entities requires some additional thoughts. You need to do more than only provide builders that create a simple object. You need to cascade your builders to provide an API that makes it easy to build a graph of entities.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#The_Domain_Model"><span class="toc_number toc_depth_1">1</span> The Domain Model</a></li><li><a href="#Creating_Builders_for_a_Graph_of_Entities"><span class="toc_number toc_depth_1">2</span> Creating Builders for a Graph of Entities</a><ul><li><a href="#The_OrderBuilder"><span class="toc_number toc_depth_2">2.1</span> The OrderBuilder</a></li><li><a href="#The_OrderItemListBuilder"><span class="toc_number toc_depth_2">2.2</span> The OrderItemListBuilder</a></li><li><a href="#The_OrderItemBuilder"><span class="toc_number toc_depth_2">2.3</span> The OrderItemBuilder</a></li></ul></li><li><a href="#Using_the_Cascaded_Builders_to_Create_a_Graph_of_Entities"><span class="toc_number toc_depth_1">3</span> Using the Cascaded Builders to Create a Graph of Entities</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="The_Domain_Model">The Domain Model</span></h2>



<p>Let’s create builders to create an&nbsp;<em>Order&nbsp;</em>with multiple&nbsp;<em>OrderItems </em>comfortably. Each <em>OrderItem</em> references a <em>Product </em>from the product catalog.</p>



<div class="wp-block-image"><figure class="aligncenter"><img width="600" height="532" src="https://thorben-janssen.com/wp-content/uploads/2019/08/class-diagram-3.png" alt="" class="wp-image-22822" srcset="https://thorben-janssen.com/wp-content/uploads/2019/08/class-diagram-3.png 600w, https://thorben-janssen.com/wp-content/uploads/2019/08/class-diagram-3-300x266.png 300w, https://thorben-janssen.com/wp-content/uploads/2019/08/class-diagram-3-338x300.png 338w" sizes="(max-width: 600px) 100vw, 600px" /><figcaption>Class diagram of the domain model</figcaption></figure></div>



<p>Without a builder, the code to create an <em>Order</em> with 2 <em>OrderItems </em>looks like this.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Order order = new Order();
order.setOrderDate(LocalDate.now());

Set&lt;OrderItem&gt; items = new HashSet&lt;OrderItem&gt;();
OrderItem item = new OrderItem();
item.setOrder(order);
item.setProduct(p1);
item.setQuantity(1);
items.add(item);

item = new OrderItem();
item.setOrder(order);
item.setProduct(p2);
item.setQuantity(2);
items.add(item);

order.setItems(items);

em.persist(order);</pre>



<p>That code isn&#8217;t complicated, but it&#8217;s long, technical and not very easy to read. You can improve that by either providing a <a href="https://thorben-janssen.com/fluent-entities-with-hibernate-and-jpa/">fluent interface</a> or by implementing a builder.</p>







<h2><span id="Creating_Builders_for_a_Graph_of_Entities">Creating Builders for a Graph of Entities</span></h2>



<p>The easiest approach to create a builder API for your entities would be to implement a builder for each entity class. But that API wouldn&#8217;t provide a lot of benefits compared to the constructor and setter methods that I used in the previous example. </p>



<p>A meaningful builder API needs to help you to create a graph of entity objects. For the example in this article, that means that you not only need to provide a builder for the <em>Order </em>and the <em>OrderItem </em>entity. You also need to support the creation of a <em>Set </em>of <em>OrderItem </em>objects for a given <em>Order</em>.</p>



<p>If you do that, you will be able to create a new <em>Order</em> with 2 <em>OrderItem</em>s like this:</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Order o = new Order.OrderBuilder()
		.withOrderDate(LocalDate.now())
		.withItems()
			.addItem().withProduct(p1).withQuantity(1).addToList()
			.addItem().withProduct(p2).withQuantity(2).addToList()
			.buildItemList()
		.buildOrder();
em.persist(o);</pre>



<p>OK, let&#8217;s take a look at the code of the builder classes that I use in the code snippet.</p>



<h3><span id="The_OrderBuilder">The <em>OrderBuilder</em></span></h3>



<p>The <em>Order </em>entity is the root of the small graph of entities. When you create an <em>Order </em>object, you can ignore the <a href="https://thorben-janssen.com/jpa-generate-primary-keys/">primary key</a> and the version attribute. These are generated attributes that you don&#8217;t need to provide when you instantiate a new object. </p>



<p>When you ignore these attributes, there are only 2 attributes left:</p>



<ul><li>the <em>orderDate </em>of type <em><a href="https://thorben-janssen.com/hibernate-5-date-and-time/">LocalDate</a> </em>and</li><li>a <em><a href="https://thorben-janssen.com/association-mappings-bag-list-set/">Set </a></em><a href="https://thorben-janssen.com/association-mappings-bag-list-set/">of </a><em><a href="https://thorben-janssen.com/association-mappings-bag-list-set/">OrderItem </a></em><a href="https://thorben-janssen.com/association-mappings-bag-list-set/">entities</a>.</li></ul>



<p>Due to that, you only need to provide a <em>withOrderDate(LocalDate orderDate)</em>, a <em>withItems(Set&lt;OrderItem&gt;items)</em> and a <em>buildOrder()</em> method to be able to build an <em>Order </em>entity object. </p>



<p>Within these methods, you can perform additional validations, e.g., check that the <em>orderDate </em>isn&#8217;t in the past or that the <em>Set </em>of <em>OrderItem</em> isn&#8217;t empty. </p>



<p>They also enable you to hide technical details. I use that in the <em>buildOrder</em> method, to hide the double linking between the <em>Order </em>and <em>OrderItem </em>objects that&#8217;s required to manage the <a href="https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/#biManyToOne">bidirectional one-to-many association</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public static final class OrderBuilder {
  private LocalDate orderDate;

  private OrderItemListBuilder itemListBuilder;

  public OrderBuilder withOrderDate(LocalDate orderDate) {
	 if (orderDate.isBefore(LocalDate.now())) {
		throw new IllegalArgumentException(&quot;OrderDate can&#039;t be in the past.&quot;);
	 }

	 this.orderDate = orderDate;
	 return this;
  }

  public OrderBuilder withItems(Set&lt;OrderItem&gt; items) {
	 if (items.isEmpty()) {
		throw new IllegalArgumentException(&quot;Order has to have at least 1 item.&quot;);
	 }
	 this.itemListBuilder = new OrderItemListBuilder(this);
	 this.itemListBuilder.items = items;
	 return this;
  }

  public OrderItemListBuilder withItems() {
	 this.itemListBuilder = new OrderItemListBuilder(this);
	 return this.itemListBuilder;
  }

  public Order buildOrder() {
	 Order o = new Order();
	 o.setOrderDate(this.orderDate);

	 // Create Set&lt;OrderItem&gt; and link with order
	 Set&lt;OrderItem&gt; items = this.itemListBuilder.items;
	 for (OrderItem item : items) {
		item.setOrder(o);
	 }
	 o.setItems(items);

	 return o;
  }
}</pre>



<p>Technically, we don&#8217;t need any additional methods. But as you can see in the code snippet, I also implement the <em>withItems()</em> method that returns an <em>OrderItemListBuilder</em> and doesn&#8217;t take any <em>OrderItem</em> entities as parameters.</p>



<p>The <em>withItems()</em> method and the <em>OrderItemsBuilder </em>class make the API much easier to use because you can use them to create new <em>OrderItem</em> objects and add them to the <em>Order</em>.</p>



<h3><span id="The_OrderItemListBuilder">The <em>OrderItemListBuilder</em></span></h3>



<p>The <em>OrderItemListBuider </em>class bridges the gap between the <em>Order </em>and the <em>OrderItemBuilder</em> by managing the <em>Set</em> of <em>OrderItem</em>s. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">public static class OrderItemListBuilder {

 private Set&lt;OrderItem&gt; items = new HashSet&lt;OrderItem&gt;();

 private OrderBuilder orderBuilder;

 public OrderItemListBuilder (OrderBuilder orderBuilder) {
	this.orderBuilder = orderBuilder;
 }

 public OrderItemListBuilder addItem(OrderItem item) {
	this.items.add(item);
	return this;
 }

 public OrderItemBuilder addItem() {
	return new OrderItem.OrderItemBuilder(this);
 }

 public OrderBuilder buildItemList() {
	return this.orderBuilder;
 }
}</pre>



<p>In contrast to the 2 other builders in this example, this class doesn&#8217;t implement any logic. It only provides the required glue code so that you can chain the method calls required to create multiple <em>OrderItem</em>s and to add them to an <em>Order</em>.</p>



<p>There are 2 important things that I want to point out:</p>



<ol><li>The reference to the <em>OrderBuilder</em> that gets provided as a constructor parameter.</li><li>The <em>buildItemList()</em>&nbsp;method that you need to call to get back to the&nbsp;<em>OrderBuilder</em>&nbsp;when you’re done adding&nbsp;<em>OrderItem</em>s to the&nbsp;<em>Set</em>. </li></ol>



<h3><span id="The_OrderItemBuilder">The <em>OrderItemBuilder</em></span></h3>



<p>The <em>OrderItemBuilder </em>implements the required methods to build an <em>OrderItem</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public static final class OrderItemBuilder {

  private Product product;

  private int quantity;

  private OrderItemListBuilder itemListBuilder;

  public OrderItemBuilder() {
	 super();
  }

  public OrderItemBuilder(OrderItemListBuilder itemListBuilder) {
	 super();
	 this.itemListBuilder = itemListBuilder;
  }

  public OrderItemBuilder withProduct(Product product) {
	 this.product = product;
	 return this;
  }

  public OrderItemBuilder withQuantity(int quantity) {
	 this.quantity = quantity;
	 return this;
  }

  public OrderItem build() {
	 OrderItem item = new OrderItem();
	 item.setProduct(this.product);
	 item.setQuantity(this.quantity);
	 return item;
  }

  public OrderItemListBuilder addToList() {
	 OrderItem item = build();
	 this.itemListBuilder.addItem(item);
	 return this.itemListBuilder;
  }
}</pre>



<p>The only method that&#8217;s not strictly required is the <em>addToList()</em> method. It creates a new <em>OrderItem</em> object and returns the <em>OrderItemListBuilder </em>so that you can keep adding <em>OrderItems </em>to the <em>Set</em>.</p>



<h2><span id="Using_the_Cascaded_Builders_to_Create_a_Graph_of_Entities">Using the Cascaded Builders to Create a Graph of Entities</span></h2>



<p>After you&#8217;ve seen the code of the 3 builder classes, let&#8217;s take another look at the business code that creates an <em>Order</em> with 2 <em>OrderItem</em>s.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">&lt;pre class=&quot;wp-block-preformatted brush: java; gutter: true&quot;&gt;Order o = new Order.OrderBuilder()
		.withOrderDate(LocalDate.now())
		.withItems()
			.addItem().withProduct(p1).withQuantity(1).addToList()
			.addItem().withProduct(p2).withQuantity(2).addToList()
			.buildItemList()
		.buildOrder();
em.persist(o);</pre></pre>



<p>In the first line, I instantiate a new <em>OrderBuilder </em>which I then use to provide the date of the order.</p>



<p>Then I want to add <em>OrderItem</em>s to the <em>Order</em>. To do that, I first call the <em>withItems()</em> method. It returns an <em>OrderItemListBuilder </em>on which I call the <em>addItem()</em> method to get an OrderItemBuilder that&#8217;s linked to the  <em>OrderItemListBuilder</em>. After I&#8217;ve set the reference to the <em>Product </em>entity and the quantity that the customer wants to order, I call the<em> addToList()</em> method. That method builds an <em>OrderItem </em>object with the provided information and adds it to the <em>Set&lt;OrderItem&gt;</em> managed by the <em>OrderItemListBuilder</em>. The method also returns the <em>OrderItemListBuilder</em> object. That allows me to either add another <em>OrderItem </em>to the <em>Set </em>or to call the <em>buildItemList()</em> to complete the creation of the <em>Set</em>.</p>



<p>In the final step, I call the <em>buildOrder()</em> method on the <em>OrderBuilder</em> to create the <em>Order </em>method. Within that method, a new <em>Order </em>object gets created, the <em>Set</em> of <em>OrderItems</em> gets filled, and each OrderItems gets associated with the <em>Order </em>entity.</p>



<p>After I&#8217;ve created the <em>Order </em>object, I provide it as a parameter to the <em>persist </em>method of the <em>EntityManager</em>. I&#8217;ve set the <em>CascadeType</em> of the <em>orderItems</em> association to <em>PERSIST </em>so that Hibernate automatically persists the associated <em>OrderItem</em> entities when I persist the <em>Order</em> entity.</p>







<h2><span id="Conclusion">Conclusion</span></h2>



<p>You can easily apply the builder pattern to your entities. In contrast to the <a href="https://thorben-janssen.com/fluent-entities-with-hibernate-and-jpa/">fluent interface pattern</a>, you don&#8217;t need to work around any technical requirements defined by the JPA specification or the Hibernate documentation.</p>



<p>To implement a good builder API, you need to cascade your builders so that you can comfortably create one or more associated entities.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>