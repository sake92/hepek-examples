<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Hibernate’s Query APIs</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Hibernate’s Query APIs</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>When working with Hibernate, you can choose between multiple APIs to query data from your database. Some of them are very flexible and provide almost unlimited options to filter and transform your query results. Others are specifically designed to implement specific tasks as easily and quickly as possible.</p>



<p>In this article, I will show you 6 different query mechanisms supported by Hibernate. 3 of them are flexible, and 3 are specialized for a specific use case. If you’re using a different JPA implementation, you should at least read about the 3 flexible and the 1st specialized options. These are defined by the JPA specification and supported by every compliant implementation.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Flexible_Query_Mechanisms"><span class="toc_number toc_depth_1">1</span> Flexible Query Mechanisms</a><ul><li><a href="#JPQL_Query"><span class="toc_number toc_depth_2">1.1</span> JPQL Query</a></li><li><a href="#Criteria_API"><span class="toc_number toc_depth_2">1.2</span> Criteria API</a></li><li><a href="#Native_SQL_Query"><span class="toc_number toc_depth_2">1.3</span> Native SQL Query</a></li></ul></li><li><a href="#Special_Purpose_APIs"><span class="toc_number toc_depth_1">2</span> Special Purpose APIs</a><ul><li><a href="#Query_by_ID"><span class="toc_number toc_depth_2">2.1</span> Query by ID</a></li><li><a href="#Query_by_multiple_IDs"><span class="toc_number toc_depth_2">2.2</span> Query by multiple IDs</a></li><li><a href="#Query_by_natural_ID"><span class="toc_number toc_depth_2">2.3</span> Query by natural ID</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="Flexible_Query_Mechanisms">Flexible Query Mechanisms</span></h2>



<p>For most uses cases, you will use one of the following flexible query mechanisms. They enable you to define a query using the projection and filter criteria that suite your use case the best.</p>



<h3><span id="JPQL_Query">JPQL Query</span></h3>



<p>JPQL is JPA&#8217;s query language. It is very similar to SQL. Its main difference is that you specify your query based on your domain model. The following code snippet shows a simple example that selects all <em>Book </em>entities with the provided phrase in their <em>title</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Book&gt; q = em.createQuery(&quot;SELECT b FROM Book b WHERE b.title like :title&quot;, Book.class);
q.setParameter(&quot;title&quot;, &quot;%Hibernate%&quot;);
List&lt;Book&gt; books = q.getResultList();</pre>



<p>When you execute this query, your persistence provider, e.g., Hibernate, generates an SQL query, sets the bind parameter values, and executes it. </p>



<p>While generating the SQL statement, Hibernate adjusts it to the dialect supported by your database. That makes your JPQL query database-independent, but it also limits you to the feature set supported by your persistence provider.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">12:32:24,711 DEBUG [org.hibernate.SQL] - 
    select
        book0_.id as id1_1_,
        book0_.price as price2_1_,
        book0_.publisherid as publishe6_1_,
        book0_.publishingDate as publishi3_1_,
        book0_.title as title4_1_,
        book0_.version as version5_1_ 
    from
        Book book0_ 
    where
        book0_.title like ? 
12:32:24,714 TRACE [org.hibernate.type.descriptor.sql.BasicBinder] - binding parameter [1] as [VARCHAR] - [%Hibernate%]</pre>



<p>You can do a lot more with JPQL. E.g., you can choose different projections in the SELECT clause, create JOIN clauses over multiple tables, order and group the query result, and call database functions. I explain all of that in great detail in my <a href="https://thorben-janssen.com/jpql/">Guide to JPQL</a>.</p>



<h3><span id="Criteria_API">Criteria API</span></h3>



<p>The Criteria API is a set of interfaces and classes that you can use to specify a query. It supports the same feature set as JPQL. The following code snippet defines the same query as the example in the JPQL section.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&lt;Book&gt; cq = cb.createQuery(Book.class);
Root&lt;Book&gt; root = cq.from(Book.class);

ParameterExpression&lt;String&gt; title = cb.parameter(String.class);
cq.where(cb.like(root.get(Book_.title), title));

TypedQuery&lt;Book&gt; query = em.createQuery(cq);
query.setParameter(title, &quot;%Hibernate%&quot;);
List&lt;Book&gt; books = query.getResultList();</pre>



<p>As you can see, using the Criteria API requires more code than a JPQL query. But it is much easier to adjust based on user input and easier to refactor.</p>



<p>When you execute this query, Hibernate generates the same query as for the previously shown JPQL query.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">12:55:38,455 DEBUG [org.hibernate.SQL] - 
    select
        book0_.id as id1_1_,
        book0_.price as price2_1_,
        book0_.publisherid as publishe6_1_,
        book0_.publishingDate as publishi3_1_,
        book0_.title as title4_1_,
        book0_.version as version5_1_ 
    from
        Book book0_ 
    where
        book0_.title like ? 
12:55:38,459 TRACE [org.hibernate.type.descriptor.sql.BasicBinder] - binding parameter [1] as [VARCHAR] - [%Hibernate%]
</pre>



<p>You now might ask yourself why or when you should use the Criteria API if you could do the same with a JPQL query. The Criteria API provides 2 main benefits:</p>



<ol><li>You can define your query dynamically at runtime.</li><li>If you combine it with <a href="https://thorben-janssen.com/static-metamodel/">JPA&#8217;s metamodel</a>, your query definition gets typesafe and easy to refactor.</li></ol>



<p>If none of these theoretical benefits provide real value for your specific use case, you should use a JPQL query. Otherwise, I recommend my <a href="/advanced-hibernate-online-training-wst/">Advanced Hibernate Online Training</a> in which we discuss the Criteria API in great detail.</p>



<h3><span id="Native_SQL_Query">Native SQL Query</span></h3>



<p>Hibernate executes native queries directly. It doesn&#8217;t need to generate the SQL statement. Due to this, you can use all query features supported by your database, and you are not limited by Hibernate. That makes native queries more powerful than JPQL queries and the Criteria API.</p>



<p>But that also requires you to create a native query statement that matches your database&#8217;s SQL dialect. If you deploy your application using different RDBMS, this might require different versions of the same query.</p>



<p>The following code snippet defines a native SQL query that selects all columns of all records in the <em>book </em>table in which the <em>title </em>field contains the word &#8216;Hibernate&#8217;. By providing the <em>Book.class</em> reference as the 2nd parameter to the query, I tell Hibernate to cast each record in the result set to a <em>Book </em>entity object.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q = em.createNativeQuery(&quot;SELECT * FROM book b WHERE title = :title&quot;, Book.class);
q.setParameter(&quot;title&quot;, &quot;%Hibernate%&quot;);
List&lt;Book&gt; books = (List&lt;Book&gt;) q.getResultList();</pre>



<p>If you want to learn more about this flexible and powerful approach to define your queries, you should take a closer look at my article <a href="/jpa-native-queries/">Native Queries – How to call native SQL queries with JPA &amp; Hibernate</a>.</p>



<p>You can also provide the name of a <em>@SqlResultSetMapping</em> as the 2nd parameter. It tells Hibernate to map the query result to scalar values, entity object, DTOs object, and any combination of these 3. You can learn more about it here:</p>



<ul><li><a href="/result-set-mapping-basics/">Result Set Mapping: The Basics</a></li><li><a href="/result-set-mapping-complex-mappings/">Result Set Mapping: Complex Mappings</a></li><li><a href="/result-set-mapping-constructor-result-mappings">Result Set Mapping: Constructor Result Mappings</a></li><li><a href="/result-set-mapping-hibernate-specific-mappings">Result Set Mapping: Hibernate specific mappings</a></li></ul>



<h2><span id="Special_Purpose_APIs">Special Purpose APIs</span></h2>



<p>JPA and Hibernate also define a few APIs for special purposes. These are not as flexible as the ones we discussed in the previous section, but they make the implementation of some common use cases incredibly simple.</p>



<h3><span id="Query_by_ID">Query by ID</span></h3>



<p>The <em>find</em> method on JPA&#8217;s <em>EntityManager </em>interface is a typical example of an API specifically designed for one use case. The only thing you can do with it is to load one entity object by its primary key value. This is a common task in every persistence layer, and the <em>find </em>method makes that as easy as possible.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book b = em.find(Book.class, 1L);</pre>



<p>As you&#8217;ve seen in the previous code snippet, you only need to call the find method with references to the entity&#8217;s class and the primary key value. Hibernate then generates the required SQL statement to select all columns mapped by the entity class of the record with the provided primary key.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">17:29:29,675 DEBUG [org.hibernate.SQL] - 
    select
        book0_.id as id1_0_0_,
        book0_.publishingDate as publishi2_0_0_,
        book0_.title as title3_0_0_,
        book0_.version as version4_0_0_ 
    from
        Book book0_ 
    where
        book0_.id=?
</pre>



<p>This approach also works in the same way if your primary key consists of multiple attributes. This is called a composite primary key, and <a href="https://thorben-janssen.com/primary-key-mappings-jpa-hibernate/#Manage_Composite_Primary_Keys">I explained the required mapping in a previous article</a>. And Hibernate, of course, also handles <a href="https://thorben-janssen.com/complete-guide-inheritance-strategies-jpa-hibernate/">inheritance mappings</a> that map an entity class to multiple database tables.</p>



<h3><span id="Query_by_multiple_IDs">Query by multiple IDs</span></h3>



<p>In addition to the <em>find </em>method defined by the <em>EntityManager</em>, Hibernate&#8217;s <em>Session </em>interface also provides a <em>byMultipleIds</em> method. As you might have guessed from its name, this method enables you to fetch multiple records by their primary key value.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">MultiIdentifierLoadAccess&lt;Book&gt; multi = session.byMultipleIds(Book.class);
List&lt;Book&gt; books = multi.multiLoad(1L, 2L, 3L);</pre>



<p>When you call the <em>multiLoad </em>method, Hibernate generates an SQL statement with an IN clause to load all objects with one query.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">17:38:46,979 DEBUG [org.hibernate.SQL] - 
    select
        book0_.id as id1_0_0_,
        book0_.publishingDate as publishi2_0_0_,
        book0_.title as title3_0_0_,
        book0_.version as version4_0_0_ 
    from
        Book book0_ 
    where
        book0_.id in (
            ?,?,?
        )
</pre>



<p>This might only look like a small usability feature. But as I have shown in a <a href="/fetch-multiple-entities-id-hibernate/">previous article</a>, Hibernate automatically splits this operation into multiple batches, if you load more records than your DBMS supports parameters in an IN clause. You can also decide if Hibernate shall exclude primary key references to entity objects that are already part of the 1st level cache.</p>



<h3><span id="Query_by_natural_ID">Query by natural ID</span></h3>



<p>Another common use case is to load an entity by its natural ID. Using plain JPA, you need to write a query for it. Hibernate provides an annotation to declare the natural ID attributes and an API to fetch an entity by its natural ID.</p>



<p>Let&#8217;s use that in an example. You first need to annotate one or more entity attributes with <em>@NaturalId</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;

	@NaturalId
	private String isbn;
	
	...
}</pre>



<p>After you&#8217;ve done that, you can use the <em>byNaturalId </em>method defined by Hibernate&#8217;s <em>Session</em> interface to get an instance of the <em>NaturalIdLoadAccess</em> interface. On that object, you can then call the <em>using </em>method for each part of the natural id. After you’ve provided all id components, you can execute the query by calling the&nbsp;<em>load&nbsp;</em>method.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book b = session.byNaturalId(Book.class)
				.using(Book_.isbn.getName(), &quot;123-4567890123&quot;)
				.load();</pre>



<p>Hibernate then generates a query to get the primary key value for the provided natural id. In the next step, it fetches the entity by the retrieved primary key.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">17:51:05,486 DEBUG [org.hibernate.SQL] - 
    select
        book_.id as id1_0_ 
    from
        Book book_ 
    where
        book_.isbn=?
17:51:05,499 DEBUG [org.hibernate.SQL] - 
    select
        book0_.id as id1_0_0_,
        book0_.isbn as isbn2_0_0_,
        book0_.publishingDate as publishi3_0_0_,
        book0_.title as title4_0_0_,
        book0_.version as version5_0_0_ 
    from
        Book book0_ 
    where
        book0_.id=?
</pre>



<p>To improve this approach&#8217;s performance, Hibernate caches the mapping between the natural and the primary key and tries to resolve the entity reference against all activated caches.</p>



<p>You can learn more about these optimizations, the handling of composite natural IDs, and the caching of mutable natural IDs in my <a href="/naturalid-good-way-persist-natural-ids-hibernate/">Guide to Hibernate&#8217;s NaturalID support</a>.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>As you&#8217;ve seen in this article, Hibernate supports the 3 different options defined by the JPA specification to define a query. All 3 of them are very flexible and enable you to filter the retrieved data by complex predicates, select information from multiple database tables, and transform it into the form that best suits your use case.</p>



<p>In addition to these 3 options, Hibernate also provides 3 APIs that were designed to fetch 1 entity by its primary key, multiple entities by their primary keys, and 1 entity by its natural ID. These APIs are not as flexible as the queries, but they make their supported operations as easy as possible.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>