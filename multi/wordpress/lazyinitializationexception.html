<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>LazyInitializationException – What it is and the best way to fix it</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>LazyInitializationException – What it is and the best way to fix it</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>The <em>LazyInitializationException </em>is one of the most common exceptions when working with Hibernate. There are a few easy ways to fix it. But unfortunately, you can also find lots of bad advice online. The proclaimed fixes often replace the exception with a hidden problem that will cause trouble in production. Some of them introduce performance issues, and others might create inconsistent results.</p>



<p>In the following paragraphs, I will explain to you what the <em>LazyInitializationException </em>is, which advice you should ignore, and how to fix the exception instead.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#When_does_Hibernate_throw_a_LazyInitializationException"><span class="toc_number toc_depth_1">1</span> When does Hibernate throw a LazyInitializationException</a></li><li><a href="#How_to_NOT_fix_the_LazyInitializationException"><span class="toc_number toc_depth_1">2</span> How to NOT fix the LazyInitializationException</a><ul><li><a href="#Don8217t_use_FetchTypeEAGER"><span class="toc_number toc_depth_2">2.1</span> Don&#8217;t use FetchType.EAGER</a></li><li><a href="#Avoid_the_Open_Session_in_View_anti-pattern"><span class="toc_number toc_depth_2">2.2</span> Avoid the Open Session in View anti-pattern</a></li><li><a href="#Don8217t_use_hibernateenable_lazy_load_no_trans"><span class="toc_number toc_depth_2">2.3</span> Don&#8217;t use hibernate.enable_lazy_load_no_trans</a></li></ul></li><li><a href="#How_to_fix_the_LazyInitializationException"><span class="toc_number toc_depth_1">3</span> How to fix the LazyInitializationException</a><ul><li><a href="#Initializing_associations_with_a_LEFT_JOIN_FETCH_clause"><span class="toc_number toc_depth_2">3.1</span> Initializing associations with a LEFT JOIN FETCH clause</a></li><li><a href="#Use_a_NamedEntityGraph_to_initialize_an_association"><span class="toc_number toc_depth_2">3.2</span> Use a @NamedEntityGraph to initialize an association</a></li><li><a href="#EntityGraph_to_initialize_an_association"><span class="toc_number toc_depth_2">3.3</span> EntityGraph to initialize an association</a></li><li><a href="#Using_a_DTO_projection"><span class="toc_number toc_depth_2">3.4</span> Using a DTO projection</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="When_does_Hibernate_throw_a_LazyInitializationException">When does Hibernate throw a LazyInitializationException</span></h2>



<p>Hibernate throws the <em>LazyInitializationException </em>when it needs to initialize a lazily fetched association to another entity without an active session context. That&#8217;s usually the case if you try to use an uninitialized association in your client application or web layer.</p>



<p>Here you can see a test case with a simplified example.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

TypedQuery&lt;Author&gt; q = em.createQuery(
		&quot;SELECT a FROM Author a&quot;,
		Author.class);
List&lt;Author&gt; authors = q.getResultList();
em.getTransaction().commit();
em.close();

for (Author author : authors) {
	List&lt;Book&gt; books = author.getBooks();
	log.info(&quot;... the next line will throw LazyInitializationException ...&quot;);
	books.size();
}</pre>



<p>The database query returns an <em>Author </em>entity with a lazily fetched association to the books this author has written. Hibernate initializes the <em>books </em>attributes with its own <em>List</em> implementation, which handles the lazy loading. When you try to access an element in that <em>List </em>or call a method that operates on its elements, Hibernate&#8217;s <em>List </em>implementation recognizes that no active session is available and throws a <em>LazyInitializationException</em>.</p>



<h2><span id="How_to_NOT_fix_the_LazyInitializationException">How to NOT fix the LazyInitializationException</span></h2>



<p>As I wrote at the beginning, you can find lots of bad advice on how to fix the <em>LazyInitializationException</em>. Let me quickly explain which suggestions you should ignore.</p>



<h3><span id="Don8217t_use_FetchTypeEAGER">Don&#8217;t use FetchType.EAGER</span></h3>



<p>Some developers suggest changing the <em><a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">FetchType</a> </em>of the association to <em>EAGER</em>. This, of course, fixes the <em>LazyInitializationException</em>,<em> </em>but it introduces performance problems that will show up in production.</p>



<p>When you set the <em>FetchType </em>to <em>EAGER</em>, Hibernate will always fetch the association, even if you don&#8217;t use it in your use case. That obviously causes an overhead that slows down your application. But it gets even worse if you don&#8217;t use the <em>EntityManager</em>.find method and don&#8217;t reference the association in a<em> JOIN FETCH</em> clause. Hibernate then executes an additional query to fetch the association. This often results in the <a href="https://thorben-janssen.com/free-n1_select_course/">n+1 select issue</a>, which is the most common cause of performance issues.</p>



<p>So please, don&#8217;t use <em>FetchType.EAGER</em>. As explained in <a href="https://thorben-janssen.com/6-hibernate-mappings-you-should-avoid-for-high-performance-applications/">various</a> <a href="https://thorben-janssen.com/best-practices-for-many-to-many-associations-with-hibernate-and-jpa/">articles</a> on this blog, you should always prefer <em>FetchType.LAZY</em>.</p>



<h3><span id="Avoid_the_Open_Session_in_View_anti-pattern">Avoid the Open Session in View anti-pattern</span></h3>



<p>When using the Open Session in View anti-patter, you open and close the <em>EntityManager </em>or Hibernate <em>Session </em>in your view layer. You then call the service layer, which opens and commits a database transaction. Because the <em>Session </em>is still open after the service layer returned the entity, the view layer can then initialize the lazily fetched association.</p>



<p>But after the service layer committed the database transaction, there is no active transaction. Because of that, Hibernate executes each SQL statement triggered by the view layer in auto-commit mode. This increases the load on the database server because it has to handle an extra transaction for each SQL statement. At the end of each of these transactions, the database has to write the transaction log to the disc, which is an expensive operation.</p>



<p>The increased pressure on your database isn&#8217;t the only downside of this anti-pattern. It can also produce inconsistent results because you are now using 2 or more independent transactions. As a result, the lazily fetched association might return different data than your service layer used to perform the business logic. Your view layer then presents both information together and it might seem like your application manages inconsistent data.</p>



<p>Unfortunately, Spring Boot uses the Open Session in View anti-pattern by default. It only logs a warning message.</p>



<pre class="wp-block-preformatted brush: bash; gutter: true">2020-03-06 16:18:21.292  WARN 11552 --- [  restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</pre>



<p>You can deactivate it by setting the <em>spring.jpa.open-in-view</em> parameter in your <em>application.properties</em> file to <em>false</em>.</p>



<h3><span id="Don8217t_use_hibernateenable_lazy_load_no_trans">Don&#8217;t use hibernate.enable_lazy_load_no_trans</span></h3>



<p>Another suggestion you should avoid is to set the <em>hibernate.enable_lazy_load_no_trans</em> configuration parameter in the <em>persistence.xml</em> file to true. This parameter tells Hibernate to open a temporary <em>Session </em>when no active <em>Session </em>is available to initialize the lazily fetched association. This increases the number of used database connections, database transactions and the overall load on your database. </p>



<p>OK, so what should you do instead?</p>



<h2><span id="How_to_fix_the_LazyInitializationException">How to fix the LazyInitializationException</span></h2>



<p>The right way to fix a <em>LazyInitializationException </em>is to fetch all required associations within your service layer. The best option for that is to load the entity with all required associations in one query. Or you can use a DTO projection, which doesn&#8217;t support lazy loading and needs to be fully initialized before you return it to the client.</p>



<p>Let&#8217;s take a closer look at the different options to initialize lazily fetched association and at the best way to use DTO projections.</p>



<h3><span id="Initializing_associations_with_a_LEFT_JOIN_FETCH_clause">Initializing associations with a LEFT JOIN FETCH clause</span></h3>



<p>The easiest way to load an entity with all required associations is to perform a JPQL or Criteria Query with one or more <em>LEFT JOIN FETCH </em>clauses. That tells Hibernate to not only fetch the entity referenced in the projection but also to fetch all associated entities referenced in the<em> LEFT JOIN FETCH</em> clause.</p>



<p>Here you can see a simple example of such a query. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a LEFT JOIN FETCH a.books&quot;, Author.class);
List&lt;Author&gt; authors = q.getResultList();

em.getTransaction().commit();
em.close();

for (Author a : authors) {
	log.info(a.getName() + &quot; wrote the books &quot; 
		+ a.getBooks().stream().map(b -&gt; b.getTitle()).collect(Collectors.joining(&quot;, &quot;))
	);
}</pre>



<p>The query selects <em>Author </em>entities, and the LEFT JOIN FETCH clause tells Hibernate to also fetch the associated <em>Book </em>entities. As you can see in the generated SQL statement, Hibernate not only joins the 2 corresponding tables in the FROM clause, it also added all columns mapped by the<em> Book</em> entity to the SELECT clause. </p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.id as id1_0_0_,
	books1_.id as id1_2_1_,
	author0_.name as name2_0_0_,
	author0_.version as version3_0_0_,
	books1_.author_id as author_i7_2_1_,
	books1_.authorEager_id as authorEa8_2_1_,
	books1_.publisher as publishe2_2_1_,
	books1_.publishingDate as publishi3_2_1_,
	books1_.sells as sells4_2_1_,
	books1_.title as title5_2_1_,
	books1_.version as version6_2_1_,
	books1_.author_id as author_i7_2_0__,
	books1_.id as id1_2_0__ 
from
	Author author0_ 
left outer join
	Book books1_ 
		on author0_.id=books1_.author_id</pre>



<p>As you can see in the log messages, the query returned an <em>Author </em>entity with an initialized <em>books </em>association.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">16:56:23,169 INFO  [org.thoughtsonjava.lazyintitializationexception.TestLazyInitializationException] - Thorben Janssen wrote the books Hibernate Tips - More than 70 solutions to common Hibernate problems</pre>



<h3><span id="Use_a_NamedEntityGraph_to_initialize_an_association">Use a <em>@NamedEntityGraph</em> to initialize an association</span></h3>



<p>You can do the same using a <em>@NamedEntityGraph</em>. The main difference is that the definition of the graph is independent of the query. That enables you to use the same query with different graphs or to use the same graph with various queries.</p>



<p>I explained <em>@NamedEntityGraphs</em> in great detail in a <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">previous article</a>. So, I keep the explanation short. You can define the graph by annotating one of your entity classes with a <em>@NamedEntityGraph</em> annotation. Within this annotation, you can provide multiple <em>@NamedAttributeNode</em> annotations to specify the attributes that Hibernate shall fetch.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@NamedEntityGraph(
    name = &quot;graph.authorBooks&quot;,
    attributeNodes = @NamedAttributeNode(&quot;books&quot;)
)
@Entity
public class Author { ... }</pre>



<p>To use this graph, you first need to get a reference to it from your <em>EntityManager</em>. In the next step, you can set it as a hint on your query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

EntityGraph&lt;?&gt; entityGraph = em.createEntityGraph(&quot;graph.authorBooks&quot;);
TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class)
		.setHint(&quot;javax.persistence.fetchgraph&quot;, entityGraph);
List&lt;Author&gt; authors = q.getResultList();

em.getTransaction().commit();
em.close();

for (Author a : authors) {
	log.info(a.getName() + &quot; wrote the books &quot; 
		+ a.getBooks().stream().map(b -&gt; b.getTitle()).collect(Collectors.joining(&quot;, &quot;))
	);
}</pre>



<p>If you look at the generated SQL statement, you can see that there is no difference between a <em>LEFT JOIN FETCH</em> clause and a <em>@NamedEntityGraph</em>. Both approaches result in a query that selects all columns mapped by the <em>Author </em>and the <em>Book </em>entity and return <em>Author </em>entities with an initialized <em>books </em>association.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.id as id1_0_0_,
	books1_.id as id1_2_1_,
	author0_.name as name2_0_0_,
	author0_.version as version3_0_0_,
	books1_.author_id as author_i7_2_1_,
	books1_.authorEager_id as authorEa8_2_1_,
	books1_.publisher as publishe2_2_1_,
	books1_.publishingDate as publishi3_2_1_,
	books1_.sells as sells4_2_1_,
	books1_.title as title5_2_1_,
	books1_.version as version6_2_1_,
	books1_.author_id as author_i7_2_0__,
	books1_.id as id1_2_0__ 
from
	Author author0_ 
left outer join
	Book books1_ 
		on author0_.id=books1_.author_id</pre>



<h3><span id="EntityGraph_to_initialize_an_association">EntityGraph to initialize an association</span></h3>



<p>The <em>EntityGraph </em>API provides you the same functionality as the <em>@NamedEntityGraph</em> annotation. The only difference is that you use a Java API instead of annotations to define the graph. That enables you to adjust the graph definition dynamically.</p>



<p>As you can see in the code snippet, the API-based definition of the graph follows the same concepts as the annotation-based definition. You first create the graph by calling the <em>createEntityGraph</em> method. In the next step, you can add multiple attributes nodes and subgraphs to the graph. I explain all of that in great detail in <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-2-define/">JPA Entity Graphs: How to Dynamically Define and Use an EntityGraph</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

EntityGraph&lt;Author&gt; entityGraph = em.createEntityGraph(Author.class);
entityGraph.addAttributeNodes(&quot;books&quot;);
TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class)
		.setHint(&quot;javax.persistence.fetchgraph&quot;, entityGraph);
List&lt;Author&gt; authors = q.getResultList();

em.getTransaction().commit();
em.close();

for (Author a : authors) {
	log.info(a.getName() + &quot; wrote the books &quot; 
		+ a.getBooks().stream().map(b -&gt; b.getTitle()).collect(Collectors.joining(&quot;, &quot;))
	);
}</pre>



<p>After you defined the graph, you can use it in the same way as a <em>@NamedEntityGraph</em>, and Hibernate generates an identical query for both of them.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.id as id1_0_0_,
	books1_.id as id1_2_1_,
	author0_.name as name2_0_0_,
	author0_.version as version3_0_0_,
	books1_.author_id as author_i7_2_1_,
	books1_.authorEager_id as authorEa8_2_1_,
	books1_.publisher as publishe2_2_1_,
	books1_.publishingDate as publishi3_2_1_,
	books1_.sells as sells4_2_1_,
	books1_.title as title5_2_1_,
	books1_.version as version6_2_1_,
	books1_.author_id as author_i7_2_0__,
	books1_.id as id1_2_0__ 
from
	Author author0_ 
left outer join
	Book books1_ 
		on author0_.id=books1_.author_id</pre>



<h3><span id="Using_a_DTO_projection">Using a DTO projection</span></h3>



<p>Fetching all required associations when you load the entity fixes the <em>LazyInitializationException</em>. But there is an alternative that&#8217;s an even better fit for all read operations. As I showed in a previous article, <a href="https://thorben-janssen.com/entities-dtos-use-projection/">DTO projections provide significantly better performance</a> if you don&#8217;t want to change the retrieved information.</p>



<p>In these situations, you can use a constructor expression to tell Hibernate to instantiate a DTO object for each record in the result set.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

TypedQuery&lt;AuthorDto&gt; q = em.createQuery(
		&quot;SELECT new org.thoughtsonjava.lazyintitializationexception.dto.AuthorDto(a.name,b.title) FROM Author a JOIN a.books b&quot;,
		AuthorDto.class);
List&lt;AuthorDto&gt; authors = q.getResultList();

em.getTransaction().commit();
em.close();

for (AuthorDto author : authors) {
	log.info(author.getName() + &quot; wrote the book &quot; + author.getBookTitle());
}</pre>



<p>Hibernate then generates an SQL statement that only selects the columns that are mapped by the attributes that you reference in the constructor call. This often reduces the number of selected columns and improves the performance even further.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">select
	author0_.name as col_0_0_,
	books1_.title as col_1_0_ 
from
	Author author0_ 
inner join
	Book books1_ 
		on author0_.id=books1_.author_id</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>If you have used Hibernate for a while, you probably had to fix at least one <em>LazyInitializationException</em>. It&#8217;s one of the most common ones when working with Hibernate.</p>



<p>As I explained in this article, you can find lots of advice online on how to fix this exception. But a lot of these suggestions only replace the exception with problems that will show up in production.</p>



<p>There are only 2 good solutions to this problem:</p>



<ol><li>You initialize all required associations when you load the entity using a <em>LEFT JOIN FETCH </em>clause or a <em>@NamedEntityGraph</em> or the <em>EntityGraph </em>API.</li><li>You use a DTO projection instead of entities. DTOs don&#8217;t support lazy loading, and you need to fetch all required information within your service layer.</li></ol></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>