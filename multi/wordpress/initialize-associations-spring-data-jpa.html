<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>How to Initialize Entity Associations with Spring Data JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>How to Initialize Entity Associations with Spring Data JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>When we&#8217;re talking about performance optimizations for Spring Data JPA, the handling of associations is always an important topic. Because Spring Data JPA is based on JPA and most often used with Hibernate, you can apply all the performance tuning concepts you can find here on the <a href="/blog">blog</a>. The most important one is to use <a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">lazy fetching</a> for all associations and combine it with query-specific fetching.</p>



<p>Ghasem wants to follow that advice and asked in a comment on a <a href="https://thorben-janssen.com/best-practices-for-many-to-many-associations-with-hibernate-and-jpa/">previous article</a> for the best way to do that:</p>



<figure class="wp-block-image size-large"><img width="714" height="317" src="https://thorben-janssen.com/wp-content/uploads/2020/11/Questions-Spring-Data-JPA-Query-Specific-Fetching.png" alt="" class="wp-image-26958" srcset="https://thorben-janssen.com/wp-content/uploads/2020/11/Questions-Spring-Data-JPA-Query-Specific-Fetching.png 714w, https://thorben-janssen.com/wp-content/uploads/2020/11/Questions-Spring-Data-JPA-Query-Specific-Fetching-300x133.png 300w, https://thorben-janssen.com/wp-content/uploads/2020/11/Questions-Spring-Data-JPA-Query-Specific-Fetching-400x178.png 400w" sizes="(max-width: 714px) 100vw, 714px" /></figure>



<figure class="wp-block-embed-youtube alignright wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<span class="dsMnZD0Yjc1pXuJ4Smr7y9WowGfA5"><iframe title="5 ways to initialize lazy associations and when to use them" width="500" height="281" src="https://www.youtube.com/embed/Dr5Qn6NC-3Y?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></span>
</div></figure>



<p>Defining your query using Spring Data&#8217;s @Query annotation is one option. It allows you to define a custom query, provides great flexibility, and is easy to use. But it&#8217;s not your only option. You can also add a @NamedEntityGraph reference to your query method or implement a custom repository method that uses JPA&#8217;s EntityGraph API. In this article, I will show you all 3 options and explain when you should use them.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Query_8211_Custom_query_with_fetching_behavior"><span class="toc_number toc_depth_1">1</span> @Query &#8211; Custom query with fetching behavior</a></li><li><a href="#EntityGraph_8211_Add_a_graph_reference_to_your_repository_method"><span class="toc_number toc_depth_1">2</span> @EntityGraph &#8211; Add a graph reference to your repository method</a></li><li><a href="#Composite_repository_8211_Programmatic_fetching_definition"><span class="toc_number toc_depth_1">3</span> Composite repository &#8211; Programmatic fetching definition</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="Query_8211_Custom_query_with_fetching_behavior">@Query &#8211; Custom query with fetching behavior</span></h2>



<p>Spring Data JPA&#8217;s repositories not only provide you with a set of ready-to-use methods to persist new entity objects or to fetch existing ones via their primary key. You can also provide your own <a href="https://thorben-janssen.com/jpql/">JPQL</a> or <a href="https://thorben-janssen.com/native-queries-with-spring-data-jpa/">native SQL</a> statement, and Spring Data provides the <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">required code to execute it</a>.</p>



<p>The only thing you need to do is add a method to your repository and annotate it with @Query. You can then provide your JPQL statement as the value of that annotation. Within that statement, you can use one or more JOIN FETCH clauses to specify the associations you want to initialize.</p>



<p>In the following code snippet, I use this approach to define a query that returns all Author entities with their books that have a given first and last name.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; {
  
    @Query(&quot;SELECT a FROM Author a LEFT JOIN FETCH a.books WHERE firstName = ?1 AND lastName = ?2&quot;)
    List&lt;Author&gt; findByFirstNameAndLastNameWithBooks(String firstName, String lastName);
  
}</pre>



<p>This is a great approach for all use case specific queries because it combines the query statement with the definition of the required fetching behavior. But sometimes, you want to execute the same query in multiple contexts that require different fetching behavior. You then either need to provide a separate repository method and query for each context, or you need to define the fetching behavior programmatically.</p>



<h2><span id="EntityGraph_8211_Add_a_graph_reference_to_your_repository_method">@EntityGraph &#8211; Add a graph reference to your repository method</span></h2>



<p>JPA&#8217;s @NamedEntityGraph annotation enables you to create a query-independent graph definition that references the associations you want to initialize. I explained this in great detail in the first part of my <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">guide to JPA&#8217;s entity graphs</a>.</p>



<p>The following graph tells your persistence provider to fetch the <em>books </em>attribute of the entity returned by your query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@NamedEntityGraph(name = &quot;graph.Author.books&quot;, 
               attributeNodes = @NamedAttributeNode(value = &quot;books&quot;))
public class Author { ... }</pre>



<p>In the next step, you need to combine this graph definition with a query that returns the entities for which you want to initialize the <em>books</em> attribute. Using plain JPA, this would <a href="/jpa-21-entity-graph-part-1-named-entity/#Named_entity_graph">require some boilerplate code</a>. But thanks to Spring Data JPA, you can do the same by adding the <em>@EntityGraph</em> annotation to your repository method. Using this annotation, you can then reference the graph by its name and define if you want to use it as a fetch or a load graph.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; {
  
    @EntityGraph(value = &quot;graph.Author.books&quot;, type = EntityGraphType.LOAD)
    List&lt;Author&gt; findByFirstNameAndLastName(String firstName, String lastName);
  
}</pre>



<p>Spring Data JPA then <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derives the query from the method name</a>, instantiates an entity graph with the name <em>graph.Author.books</em>, combines the graph with the query, and executes it.</p>



<h2><span id="Composite_repository_8211_Programmatic_fetching_definition">Composite repository &#8211; Programmatic fetching definition</span></h2>



<p>Your 3rd option to fetch an association using Spring Data JPA is to use a <a href="https://thorben-janssen.com/composite-repositories-spring-data-jpa/">composite repository</a>. It&#8217;s by far the most flexible approach but it also requires the most work.</p>



<p>A composite repository enables you to add your own method implementation to a Spring Data JPA repository. This requires the definition of a fragment interface that defines the method you want to implement and a class that implements the fragment interface.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface CustomAuthorRepository {
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public List&amp;lt;Author&amp;gt;&amp;nbsp; getAuthorsByFirstName(String firstName, boolean withBooks);
}</pre>



<p>Within the method implementation, you can use the <em>EntityManager </em>with all features supported by the JPA specification and your persistence provider, e.g., Hibernate. This, of course, would allow you to execute a JPQL query with a JOIN FETCH clause or to execute a query with a <em>@NamedEntityGraph</em>. But as I showed before, Spring Data JPA&#8217;s integrations are much easier to use.</p>



<p>A composite repository is only required if you want to use JPA&#8217;s <em>EntityGraph </em>API to define your graph at runtime. This can be useful if your graph definition depends on user input.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public class CustomAuthorRepositoryImpl implements CustomAuthorRepository {
 
    private EntityManager entityManager;

    public CustomAuthorRepositoryImpl(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
 
    @Override
    public List&lt;Author&gt; getAuthorsByFirstName(String firstName, boolean withBooks) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Author&gt; query = cb.createQuery(Author.class);
        Root&lt;Author&gt; root = query.from(Author.class);
        query.select(root)
                .where(cb.equal(root.get(Author_.firstName), firstName));
 
        TypedQuery&lt;Author&gt; q = entityManager.createQuery(query);
        if (withBooks) {
            EntityGraph&lt;Author&gt; graph = this.em.createEntityGraph(Author.class);
            graph.addAttributeNodes(&quot;books&quot;);
            q.setHint(&quot;javax.persistence.loadgraph&quot;, graph);
        }

        return q.getResultList();
    }
 
}</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>As you have seen, annotating your repository method with <em>@Query</em> and providing a JPQL statement with one or more JOIN FETCH clauses is by far the easiest approach to initialize an association. As long as there are no other requirements, this is my preferred approach.</p>



<p>If you&#8217;re using plain JPA, named entity graphs are useful to execute the same query with different fetching behaviors. But because Spring Data JPA makes it so easy to add custom queries to a repository, I usually prefer them over entity graphs.</p>



<p>The composite repository requires much more code than the 2 previously discussed options. That&#8217;s why I only recommend using it if your implementation benefits from the additional flexibility. </p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>