<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Hibernate Performance Tuning – 2023 Edition</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" /><style>
    nav#tocScrollspy {
      display: none;
    }

    @media (min-width: 991px) {
      .affix {
          position: fixed;
          width: 10%;
      }

      nav#tocScrollspy {
        display: block;
      }
    }
    </style></head><body><div class="container-fluid"><div><div class="page-header text-center"><h1>Hibernate Performance Tuning – 2023 Edition</h1></div><div class="row"><div class="col-lg-2 col-md-0 invisible"></div><div class="col-lg-8 col-md-12">
<p>Based on most discussions online and at conferences, there seem to be 2 kinds of projects that use Hibernate for their persistence layer. Most use it with great success and have only minor complaints about some syntax or APIs. Others complain ferociously about Hibernate&#8217;s performance and how inefficient it handles basic use cases.</p>



<p>So, what&#8217;s the difference between these projects? Are the projects in group 2 more complex or have higher performance requirements?</p>



<p>No, based on my consulting projects, that&#8217;s not the case. On average, the complexity and performance requirements of the projects in group 2 might be a little higher. But you can find many projects in group 1 with similar performance requirements and complexity. And if some teams are able to solve these problems and are happy with using Hibernate, there have to be other reasons why some teams and projects struggle with Hibernate problems.</p>



<p>These reasons become quite obvious in my consulting projects. It&#8217;s how the teams use Hibernate and how much they know about it.</p>



<p>In my consulting projects, I see 2 main mistakes that cause most performance problems:</p>



<ol>
<li>Checking no or the wrong log messages during development makes it impossible to find potential issues.</li>



<li>Misusing some of Hibernate&#8217;s features forces it to execute additional SQL statements, which quickly escalates in production.</li>
</ol>



<p>In the first section of this article, I will show you a logging configuration that helps you identify performance issues during development. After that, I will show you how to avoid these problems using Hibernate 4, 5, and 6. And if you want to learn more about Hibernate, I recommend you join the <a href="/join-persistence-hub/">Persistence Hub</a>. It gives you access to a set of exclusive certification courses (incl. one about Hibernate performance tuning), monthly expert sessions, monthly coding challenges, and Q&amp;A calls.</p>



<!--more-->



<h2 class="wp-block-heading">Find performance issues during development</h2>



<p>Finding the performance issues before they cause trouble in production is always the most critical part. But that&#8217;s often not as easy as it sounds. </p>



<p>Most performance issues are hardly visible on a small test system. They are caused by inefficiencies that scale based on the size of your database and the number of parallel users. Due to that, they have almost no performance impact when running your tests using a small database and only one user. But that changes dramatically as soon as you deploy your application to production.</p>



<p>While the performance issues are hard to find on your test system, you can still see these inefficiencies if you use the right Hibernate configuration.</p>



<p>Hibernate can keep detailed statistics on the operations it performed and how long they took. You <a href="//thorben-janssen.com/how-to-activate-hibernate-statistics-to-analyze-performance-issues/" target="_blank" rel="noopener noreferrer">activate Hibernate&#8217;s statistics</a> by setting the system property <em>hibernate.generate_statistics</em> to <em>true</em> and the log level of the <em>org.hibernate.stat</em> category to <em>DEBUG</em>. </p>



<p>Hibernate will then collect many internal statistics and summarize the most important metrics at the end of each session. For each executed query, it also prints out the statement, its execution time, and the number of returned rows.</p>



<p>Here you can see an example of such a summary:</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
07:03:29,976 DEBUG &#x5B;org.hibernate.stat.internal.StatisticsImpl] - HHH000117: HQL: SELECT p FROM ChessPlayer p LEFT JOIN FETCH p.gamesWhite LEFT JOIN FETCH p.gamesBlack ORDER BY p.id, time: 10ms, rows: 4
07:03:30,028 INFO  &#x5B;org.hibernate.engine.internal.StatisticalLoggingSessionEventListener] - Session Metrics {
    46700 nanoseconds spent acquiring 1 JDBC connections;
    43700 nanoseconds spent releasing 1 JDBC connections;
    383099 nanoseconds spent preparing 5 JDBC statements;
    11505900 nanoseconds spent executing 4 JDBC statements;
    8895301 nanoseconds spent executing 1 JDBC batches;
    0 nanoseconds spent performing 0 L2C puts;
    0 nanoseconds spent performing 0 L2C hits;
    0 nanoseconds spent performing 0 L2C misses;
    26450200 nanoseconds spent executing 1 flushes (flushing a total of 17 entities and 10 collections);
    12322500 nanoseconds spent executing 1 partial-flushes (flushing a total of 1 entities and 1 collections)
}
</pre></div>


<p>As you can see in the log output, Hibernate tells you how many JDBC statements it executed, if it used JDBC batching, how it used the 2nd level cache, how many flushes it performed, and how long they took. </p>



<p>That gives you an overview of all the database operations your use case performed. You can avoid the most common issues caused by slow queries, too many queries, and missing cache usage by checking these statistics while working on your persistence layer.</p>



<p>When doing that, please keep in mind that you are working with a small test database. 5 or 10 additional queries during your test might become several hundred or thousands if you switch to the bigger production database.</p>



<p>If you&#8217;re using <strong>Hibernate </strong>in at least <strong>version 5.4.5</strong>, you should also configure a threshold for Hibernate&#8217;s slow query log. You can do that by configuring the property <em>hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS</em> in your persistence.xml file.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: xml; title: ; notranslate" title="">
&lt;persistence&gt;
	&lt;persistence-unit name=&quot;my-persistence-unit&quot;&gt;
		...

		&lt;properties&gt;
			&lt;property name=&quot;hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS&quot; value=&quot;1&quot; /&gt;
			...
		&lt;/properties&gt;
	&lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre></div>


<p>Hibernate then measures the pure execution time of each query and writes a log message for each one that takes longer than the configured threshold.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
12:23:20,545 INFO  &#x5B;org.hibernate.SQL_SLOW] - SlowQuery: 6 milliseconds. SQL: 'select a1_0.id,a1_0.firstName,a1_0.lastName,a1_0.version from Author a1_0'
</pre></div>


<h2 class="wp-block-heading">Improve slow queries</h2>



<p>Using the previously described configuration, you will regularly find slow queries. But they are not a real JPA or Hibernate issue. This kind of performance problem occurs with every framework, even with plain SQL over JDBC. That&#8217;s why your database provides different tools to analyze an SQL statement.</p>



<p>When improving your queries, you might use some database-specific query features not supported by JPQL and the Criteria API. But don’t worry. You can still use your optimized query with Hibernate. You can execute it as a native query.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Author a = (Author) em.createNativeQuery(&quot;SELECT * FROM Author a WHERE a.id = 1&quot;, Author.class).getSingleResult();
</pre></div>


<p>Hibernate doesn&#8217;t parse a native query statement. That enables you to use all SQL and proprietary features your database supports. But it also has a drawback. You get the query result as an&nbsp;<em>Object[]</em>&nbsp;instead of the strongly typed results returned by a JPQL query.</p>



<p>If you want to map the query result to entity objects, you only need to select all columns mapped by your entity and provide its class as the 2nd parameter. Hibernate then automatically applies the entity mapping to your query result. I did that in the previous code snippet.</p>



<p>And if you want to map the result to a different data structure, you either need to map it programmatically or use JPA&#8217;s&nbsp;<em>@SqlResultSetMapping</em>&nbsp;annotations. I explained that in great detail in a series of articles:</p>



<ul>
<li><a title="Result Set Mapping: The Basics" href="//thorben-janssen.com/result-set-mapping-basics/" target="_blank" rel="noopener noreferrer">Result Set Mapping: The Basics</a></li>



<li><a href="//thorben-janssen.com/2015/04/result-set-mapping-complex.html" target="_blank" rel="noopener noreferrer">Result Set Mapping: Complex Mappings</a></li>



<li><a href="//thorben-janssen.com/result-set-mapping-constructor-result-mappings/">Result Set Mapping: Constructor&nbsp;Result&nbsp;Mappings</a></li>



<li><a title="Result Set Mapping: Hibernate specific mappings" href="//thorben-janssen.com/result-set-mapping-hibernate-specific-mappings/">Result Set Mapping: Hibernate specific features</a></li>
</ul>



<h2 class="wp-block-heading">Avoid unnecessary queries &#8211; Choose the right <em>FetchType</em></h2>



<p>Another common issue you will find after activating Hibernate&#8217;s statistics is the execution of unnecessary queries. This often happens because Hibernate has to initialize an eagerly fetched association, which you do not even use in your business code. </p>



<p>That&#8217;s a typical mapping error that defines the wrong <em>FetchType.</em> It is specified in the entity mapping and defines when an association will be loaded from the database:</p>



<ul>
<li><em>FetchType.LAZY</em> tells your persistence provider to initialize an association when you use it for the first time. This is obviously the most efficient approach, and it&#8217;s the default for all to-many associations.</li>



<li><em>FetchType.EAGER</em> forces Hibernate to initialize the association when instantiating the entity object. It&#8217;s the default for all to-one associations. </li>
</ul>



<p>In most cases, each eagerly fetched association of every fetched entity causes an additional database query. Depending on your use case and the size of your database, this can quickly add up to a few hundred additional queries.</p>



<p>To avoid that, you should follow these best practices:</p>



<ul>
<li>All to-many associations use&nbsp;<em>FetchType.LAZY</em>&nbsp;by default, and you should not change that.</li>



<li>All to-one associations use&nbsp;<em>FetchType.EAGER</em>&nbsp;by default, and you should set it to&nbsp;<em>LAZY</em>. You can do that by setting the fetch attribute on the&nbsp;<em>@ManyToOne</em>&nbsp;or&nbsp;<em>@OneToOne</em>&nbsp;annotation.</li>
</ul>



<pre class="wp-block-preformatted brush: java; gutter: true">@ManyToOne(fetch=FetchType.LAZY)</pre>



<p>After you have ensured that all your associations use <em>FetchType.LAZY</em>, you should check all use cases using lazily fetched associations to avoid the following performance problem.</p>



<h2 class="wp-block-heading">Avoid unnecessary queries &#8211; Use query-specific fetching</h2>



<p>As I explained in the previous section, you should use <em>FetchType.LAZY</em> for all of your associations. That ensures you only fetch the ones you use in your business code. </p>



<p>But if you only change the <em>FetchType</em>, you will still cause performance problems when you use the associations in your business code. Hibernate then executes a separate query to initialize each of these associations. That problem is called the n+1 select issue.</p>



<p>The following code snippet shows a typical example using the <em>Author</em> and <em>Book </em>entity. The <em>books </em>attribute of the <em>Author </em>entity models a lazily fetched many-to-many association between both entities. When you call the <em>getBooks()</em> method, Hibernate has to initialize the association.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
List&lt;Author&gt; authors = em.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class).getResultList();
for (Author author : authors) {
	log.info(author + &quot; has written &quot; + author.getBooks().size() + &quot; books.&quot;);
}
</pre></div>


<p>As you can see in the log output, the JPQL query only gets the <em>Author</em> entity from the database and doesn&#8217;t initialize the <em>books</em> association. Because of that, Hibernate needs to execute an additional query when you call <em>getBooks() </em>method of each <em>Author </em>entity for the first time. </p>



<p>On my small test database, which only contains 11 <em>Author</em> entities, this initialization causes 11 additional queries. So, in the end, the previous code snippet triggered 12 SQL statements.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
12:30:53,705 DEBUG &#x5B;org.hibernate.SQL] - select a1_0.id,a1_0.firstName,a1_0.lastName,a1_0.version from Author a1_0
12:30:53,731 DEBUG &#x5B;org.hibernate.stat.internal.StatisticsImpl] - HHH000117: HQL: SELECT a FROM Author a, time: 38ms, rows: 11
12:30:53,739 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,746 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Joshua, lastName: Bloch has written 1 books.
12:30:53,747 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,750 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Gavin, lastName: King has written 1 books.
12:30:53,750 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,753 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Christian, lastName: Bauer has written 1 books.
12:30:53,754 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,756 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Gary, lastName: Gregory has written 1 books.
12:30:53,757 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,759 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Raoul-Gabriel, lastName: Urma has written 1 books.
12:30:53,759 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,762 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Mario, lastName: Fusco has written 1 books.
12:30:53,763 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,764 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Alan, lastName: Mycroft has written 1 books.
12:30:53,765 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,768 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Andrew Lee, lastName: Rubinger has written 2 books.
12:30:53,769 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,771 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Aslak, lastName: Knutsen has written 1 books.
12:30:53,772 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,775 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Bill, lastName: Burke has written 1 books.
12:30:53,775 DEBUG &#x5B;org.hibernate.SQL] - select b1_0.authorId,b1_1.id,p1_0.id,p1_0.name,p1_0.version,b1_1.publishingDate,b1_1.title,b1_1.version from BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId left join Publisher p1_0 on p1_0.id=b1_1.publisherid where b1_0.authorId=?
12:30:53,777 INFO  &#x5B;com.thorben.janssen.hibernate.performance.TestIdentifyPerformanceIssues] - Author firstName: Scott, lastName: Oaks has written 1 books.
12:30:53,799 INFO  &#x5B;org.hibernate.engine.internal.StatisticalLoggingSessionEventListener] - Session Metrics {
    37200 nanoseconds spent acquiring 1 JDBC connections;
    23300 nanoseconds spent releasing 1 JDBC connections;
    758803 nanoseconds spent preparing 12 JDBC statements;
    23029401 nanoseconds spent executing 12 JDBC statements;
    0 nanoseconds spent executing 0 JDBC batches;
    0 nanoseconds spent performing 0 L2C puts;
    0 nanoseconds spent performing 0 L2C hits;
    0 nanoseconds spent performing 0 L2C misses;
    17618900 nanoseconds spent executing 1 flushes (flushing a total of 20 entities and 26 collections);
    21300 nanoseconds spent executing 1 partial-flushes (flushing a total of 0 entities and 0 collections)
}
</pre></div>


<p>You can avoid that by using query-specific eager fetching, which you can define in different ways.</p>



<h3 class="wp-block-heading">Use a JOIN FETCH clause</h3>



<p>The easiest option is to add a <em>JOIN FETCH</em> clause to your JPQL query. It looks similar to a simple JOIN clause that you might already use in your queries. But there is a significant difference. The additional FETCH keyword tells Hibernate to not only join the two entities within the query but also to fetch the associated entities from the database. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
List&lt;Author&gt; authors = em.createQuery(&quot;SELECT a FROM Author a JOIN FETCH a.books b&quot;, Author.class).getResultList();
</pre></div>


<p>As you can see in the log output, Hibernate generates an SQL statement that selects all columns mapped by the <em>Author </em>and <em>Book</em> entity and maps the result to managed entity objects.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
12:43:02,616 DEBUG &#x5B;org.hibernate.SQL] - select a1_0.id,b1_0.authorId,b1_1.id,b1_1.publisherid,b1_1.publishingDate,b1_1.title,b1_1.version,a1_0.firstName,a1_0.lastName,a1_0.version from Author a1_0 join (BookAuthor b1_0 join Book b1_1 on b1_1.id=b1_0.bookId) on a1_0.id=b1_0.authorId
12:43:02,650 DEBUG &#x5B;org.hibernate.stat.internal.StatisticsImpl] - HHH000117: HQL: SELECT a FROM Author a JOIN FETCH a.books b, time: 49ms, rows: 11
12:43:02,667 INFO  &#x5B;org.hibernate.engine.internal.StatisticalLoggingSessionEventListener] - Session Metrics {
    23400 nanoseconds spent acquiring 1 JDBC connections;
    26401 nanoseconds spent releasing 1 JDBC connections;
    157701 nanoseconds spent preparing 1 JDBC statements;
    2950900 nanoseconds spent executing 1 JDBC statements;
    0 nanoseconds spent executing 0 JDBC batches;
    0 nanoseconds spent performing 0 L2C puts;
    0 nanoseconds spent performing 0 L2C hits;
    0 nanoseconds spent performing 0 L2C misses;
    13037201 nanoseconds spent executing 1 flushes (flushing a total of 17 entities and 23 collections);
    20499 nanoseconds spent executing 1 partial-flushes (flushing a total of 0 entities and 0 collections)
}
</pre></div>


<p>If you&#8217;re using Hibernate 6, this is all you need to do to get all the required information in 1 query.</p>



<h4 class="wp-block-heading" id="distinctPassThrough">Avoid duplicates with Hibernate 4 and 5</h4>



<p>If you&#8217;re using <strong>Hibernate 4 or 5</strong>, you must prevent Hibernate from creating duplicates when mapping your query results. Otherwise, Hibernate returns each author as often as they have written a book.</p>



<p>You can avoid that by including the <em>DISTINCT</em> keyword in your query. Hibernate then adds the <em>DISTINCT </em>keyword to the generated SQL statement and avoids creating duplicates when mapping the query result.</p>



<p>But including the DISTINCT keyword in the SQL statement is unnecessary. The result set doesn&#8217;t contain any duplicates. We&#8217;re only adding that keyword to fix an issue with Hibernate&#8217;s result mapping. Since Hibernate 5.2.2, you can tell Hibernate to exclude the DISTINCT keyword from the SQL statement by setting the query hint <em>hibernate.query.passDistinctThrough</em> to <em>false</em>. The easiest way to set that hint is to use the constant <em>QueryHints.PASS_DISINCT_THROUGH</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
List&lt;Author&gt; authors = em.createQuery(&quot;SELECT DISTINCT a FROM Author a JOIN FETCH a.books b&quot;, Author.class)
						 .setHint(QueryHints.PASS_DISTINCT_THROUGH, false)
						 .getResultList();
</pre></div>


<h3 class="wp-block-heading">Use a @NamedEntityGraph</h3>



<p>Another option to define query-specific fetching is to use a <em>@NamedEntityGraph</em>. This was one of the <a href="//thorben-janssen.com/jpa-21-overview/">features introduced in JPA 2.1</a>, and Hibernate has supported it since version 4.3. It allows&nbsp;you to define a graph of entities that shall be fetched from the database. </p>



<p>You can see the definition of a very basic graph in the following code snippet. It tells your persistence provider to initialize the <em>books </em>attribute when fetching an entity.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@NamedEntityGraph(name = &quot;graph.AuthorBooks&quot;,  attributeNodes = @NamedAttributeNode(value = &quot;books&quot;))
</pre></div>


<p>In the next step, you need to combine the entity graph with a query that selects an entity with a <em>books</em> attribute. In the following example, that&#8217;s the&nbsp;<em>Author</em>&nbsp;entity. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
List&lt;Author&gt; authors = em
		.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class)
		.setHint(QueryHints.JAKARTA_HINT_FETCH_GRAPH, graph)
		.getResultList();
</pre></div>


<p>When you execute that code, it gives you the same result as the previous example. The <em>EntityManager </em>fetches all columns mapped by the <em>Author</em> and <em>Book</em> entity and maps them to managed entity objects.</p>



<p>You can find a more detailed description of <em>@NamedEntityGraphs</em> and how to define more complex graphs in <a href="/jpa-21-entity-graph-part-1-named-entity/">JPA Entity Graphs – Part 1: Named entity graphs</a>.</p>



<h4 class="wp-block-heading">Avoid duplicates with Hibernate versions &lt; 5.3</h4>



<p>In the <a href="#distinctPassThrough">previous section</a>, I explained that older Hibernate versions create duplicates when mapping the query result. Unfortunately, that&#8217;s also the case when using entity graphs with a <strong>Hibernate version &lt; 5.3</strong>. As explained earlier, you can avoid that by adding the DISTINCT keyword and setting the query hint <em>hibernate.query.passDistinctThrough</em> to <em>false</em>.</p>



<h3 class="wp-block-heading">Use an EntityGraph</h3>



<p>If you need a more dynamic way to define your entity graph, you can also define it <a href="//thorben-janssen.com/jpa-21-entity-graph-part-2-define/">via a Java API</a>. The following code snippet defines the same graph as the previously described annotations and combines it with a query that fetches <em>Author</em> entities. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
EntityGraph graph = em.createEntityGraph(Author.class);
Subgraph bookSubGraph = graph.addSubgraph(Author_.books);

List&lt;Author&gt; authors = em
		.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class)
		.setHint(QueryHints.JAKARTA_HINT_FETCH_GRAPH, graph)
		.getResultList();
</pre></div>


<p>Like the previous examples, Hibernate will use the graph to extend the SELECT clause with all columns mapped by the <em>Author</em> and <em>Book </em>entity and map the query result to the corresponding entity objects.</p>



<h4 class="wp-block-heading">Avoid duplicates with Hibernate versions &lt; 5.3</h4>



<p>The entity graph API and the <em>@NamedEntityGraph</em> annotations are only 2 different ways to define a graph. So, it shouldn&#8217;t be surprising that <strong>Hibernate versions &lt; 5.3</strong> have the same result mapping issues for both options. It creates duplicates when mapping the result of a query. </p>



<p>You can avoid that by adding the <em>DISTINCT</em> keyword to your query and setting the query hint  <em>hibernate.query.passDistinctThrough</em> to <em>false </em>to let Hibernate remove all duplicates from your query result. You can find a more detailed description in an <a href="#distinctPassThrough">earlier section</a>.</p>



<h2 class="wp-block-heading">Don&#8217;t model a Many-to-Many association as a List</h2>



<p>Another common mistake I see in many <a style="" href="/project-coaching/">code reviews</a> is a many-to-many association modeled as a <em>java.util.List</em>. </p>



<p>A <em>List</em> might be the most efficient collection type in Java. But unfortunately, Hibernate manages many-to-many associations very inefficiently if you model them as a <em>List</em>. If you add or remove an element, Hibernate removes all elements of the association from the database before it inserts all remaining ones.</p>



<p>Let&#8217;s take a look at a simple example. The <em>Book </em>entity models a many-to-many association to the <em>Author </em>entity as a <em>List</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
public class Book {
	
	@ManyToMany
    private List&lt;Author&gt; authors = new ArrayList&lt;Author&gt;();
	
	...
}
</pre></div>


<p>When I add an&nbsp;<em>Author&nbsp;</em>to the List of associated&nbsp;<em>authors</em>, Hibernate deletes all the association records of the given&nbsp;<em>Book&nbsp;</em>and inserts a new record for each element in the&nbsp;<em>List</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Author a = new Author();
a.setId(100L);
a.setFirstName(&quot;Thorben&quot;);
a.setLastName(&quot;Janssen&quot;);
em.persist(a);

Book b = em.find(Book.class, 1L);
b.getAuthors().add(a);
</pre></div>

<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
14:13:59,430 DEBUG &#x5B;org.hibernate.SQL] - 
    select
        b1_0.id,
        b1_0.format,
        b1_0.publishingDate,
        b1_0.title,
        b1_0.version 
    from
        Book b1_0 
    where
        b1_0.id=?
14:13:59,478 DEBUG &#x5B;org.hibernate.SQL] - 
    insert 
    into
        Author
        (firstName, lastName, version, id) 
    values
        (?, ?, ?, ?)
14:13:59,484 DEBUG &#x5B;org.hibernate.SQL] - 
    update
        Book 
    set
        format=?,
        publishingDate=?,
        title=?,
        version=? 
    where
        id=? 
        and version=?
14:13:59,489 DEBUG &#x5B;org.hibernate.SQL] - 
    delete 
    from
        book_author 
    where
        book_id=?
14:13:59,491 DEBUG &#x5B;org.hibernate.SQL] - 
    insert 
    into
        book_author
        (book_id, author_id) 
    values
        (?, ?)
14:13:59,494 DEBUG &#x5B;org.hibernate.SQL] - 
    insert 
    into
        book_author
        (book_id, author_id) 
    values
        (?, ?)
14:13:59,495 DEBUG &#x5B;org.hibernate.SQL] - 
    insert 
    into
        book_author
        (book_id, author_id) 
    values
        (?, ?)
14:13:59,499 DEBUG &#x5B;org.hibernate.SQL] - 
    insert 
    into
        book_author
        (book_id, author_id) 
    values
        (?, ?)
14:13:59,509 INFO  &#x5B;org.hibernate.engine.internal.StatisticalLoggingSessionEventListener] - Session Metrics {
    26900 nanoseconds spent acquiring 1 JDBC connections;
    35000 nanoseconds spent releasing 1 JDBC connections;
    515400 nanoseconds spent preparing 8 JDBC statements;
    24326800 nanoseconds spent executing 8 JDBC statements;
    0 nanoseconds spent executing 0 JDBC batches;
    0 nanoseconds spent performing 0 L2C puts;
    0 nanoseconds spent performing 0 L2C hits;
    0 nanoseconds spent performing 0 L2C misses;
    43404700 nanoseconds spent executing 1 flushes (flushing a total of 6 entities and 5 collections);
    0 nanoseconds spent executing 0 partial-flushes (flushing a total of 0 entities and 0 collections)
}
</pre></div>


<p>You can easily avoid this inefficiency by modeling your many-to-many association as a <em>java.util.Set</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
public class Book {
	
	@ManyToMany
    private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();
	
	...
}
</pre></div>


<h2 class="wp-block-heading">Let the database handle data-heavy operations</h2>



<p>OK, this is a recommendation that most Java developers don&#8217;t really like because it moves parts of the business logic from the business tier (implemented in Java) into the database. </p>



<p>And don’t get me wrong, there are good reasons to choose Java to implement your business logic and a database to store your data. But you also have to consider that a database handles huge datasets very efficiently. Therefore, it can be a good idea to move not too complex and very data-heavy operations into the database.</p>



<p>There are multiple ways to do that. You can use database functions to perform simple operations in JPQL and native SQL queries. If you need more complex operations, you can call a stored procedure. Since JPA 2.1/Hibernate 4.3, you can <a href="//thorben-janssen.com/call-stored-procedures-jpa/">call stored procedures via <em>@NamedStoredProcedureQuery</em></a> or the <a href="//thorben-janssen.com/call-stored-procedures-jpa-part-2/">corresponding Java API</a>. If you&#8217;re using an older Hibernate version, you can do the same by writing a native query.</p>



<p>The following code snippet shows a&nbsp;<em>@NamedStoredProcedure</em> definition for the <em>getBooks</em>&nbsp;stored procedure. This procedure returns a <em>REF_CURSOR</em> which can be used to iterate through the returned data set.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@NamedStoredProcedureQuery( 
  name = &quot;getBooks&quot;, 
  procedureName = &quot;get_books&quot;, 
  resultClasses = Book.class,
  parameters = { @StoredProcedureParameter(mode = ParameterMode.REF_CURSOR, type = void.class) }
)
</pre></div>


<p>In your code, you can then instantiate the <em>@NamedStoredProcedureQuery</em> and execute it. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
List&lt;Book&gt; books = (List&lt;Book&gt;) em.createNamedStoredProcedureQuery(&quot;getBooks&quot;)
                                       .getResultList();
</pre></div>


<h2 class="wp-block-heading">Use caches to avoid reading the same data multiple times</h2>



<p>Modular application design and parallel user sessions often result in reading the same data multiple times. Obviously, this is an overhead that you should try to avoid. One way to do this is to cache data that is often read but rarely changed.</p>



<p>As you can see below, Hibernate offers 3 different caches that you can combine with each other.</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="//thorben-janssen.com/wp-content/uploads/2015/11/caches1.png"><img decoding="async" src="//thorben-janssen.com/wp-content/uploads/2015/11/caches1.png" alt="" class="wp-image-1790"/></a></figure></div>


<p>Caching is a complex topic and can cause severe side effects. That&#8217;s why my Hibernate Performance Tuning course (included in the <a href="/join-persistence-hub/">Persistence Hub</a>) contains an entire module about it. I can only give you a quick overview of Hibernate’s 3 different caches in this article. I recommend you familiarize yourself with all the details of Hibernate’s caches before you start using them.</p>



<h3 class="wp-block-heading">1st Level Cache</h3>



<p>The 1st level cache is always active and contains all managed entities. These are all entities that you used within the current <em>Session</em>.</p>



<p>Hibernate uses it to delay the execution of write operations as long as possible. That provides multiple performance benefits, e.g., Hibernate executes 1 SQL UPDATE statement before committing the database transaction instead of executing an UPDATE statement after every call of a setter method.</p>



<p>The 1st Level Cache also ensures that only 1 entity object represents each database record within a current session. If any of your queries return an entity object already in the 1st level cache, Hibernate ignores it and gets the object from the cache.</p>



<h3 class="wp-block-heading">2nd Level Cache</h3>



<p>The Session-independent 2nd level cache also stores entities. If you want to use it, you need to activate it by setting the <em>shared-cache-mode</em> property in your <em>persistence.xml</em> file. I recommend setting it to <em>ENABLE_SELECTIVE</em> and activating caching only for the entity classes you read at least 9-10 times for each write operation.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: xml; title: ; notranslate" title="">
&lt;persistence&gt;
    &lt;persistence-unit name=&quot;my-persistence-unit&quot;&gt;
        ...
        
        &lt;!--  enable selective 2nd level cache --&gt;
    	&lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre></div>


<p>You can activate caching for an entity class by annotating it with <em>jakarta.persistence.Cacheable</em> or <em>org.hibernate.annotations.Cache</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
@Cacheable
public class Author { ... }
</pre></div>


<p>After you do that, Hibernate automatically adds new&nbsp;<em>Author&nbsp;</em>entities and the ones you fetched from the database to the 2nd level cache. It also checks if the 2nd level cache contains the requested <em>Author </em>entity before it traverses an association or generates an SQL statement for the call of the <em>EntityManager.find</em> method. But please be aware that Hibernate doesn&#8217;t use the 2nd level cache if you define your own JPQL, Criteria, or native query.</p>



<h3 class="wp-block-heading">Query Cache</h3>



<p>The query cache is the only one that does not store entities. It caches query results and contains only entity references and scalar values. You need to activate the cache by setting the <em>hibernate.cache.use_query_cache</em> property in the <em>persistence.xml</em> file and set the <em>cacheable</em> property on the <em>Query</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
Query&lt;Author&gt; q = session.createQuery(&quot;SELECT a FROM Author a WHERE id = :id&quot;, Author.class);
q.setParameter(&quot;id&quot;, 1L);
q.setCacheable(true);
Author a = q.uniqueResult();
</pre></div>


<h2 class="wp-block-heading">Perform updates and deletes in bulks</h2>



<p>Updating or deleting one entity after the other feels quite natural in Java, but it is also very inefficient. Hibernate creates one SQL query for each entity that was updated or deleted. A better approach would be to perform these operations in bulk by creating update or delete statements affecting multiple records simultaneously.</p>



<p>You can do this via JPQL, SQL statements, or <a style="" href="//thorben-janssen.com/criteria-updatedelete-easy-way-to/" target="_blank" rel="noopener noreferrer"><em>CriteriaUpdate</em> and <em>CriteriaDelete</em> operations</a>. The following code snippet shows an example of a <em>CriteriaUpdate</em> statement. As you can see, it is used similarly to the already-known <em>CriteriaQuery</em> statements.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
CriteriaBuilder cb = this.em.getCriteriaBuilder();
   
// create update
CriteriaUpdate&lt;Order&gt; update = cb.createCriteriaUpdate(Order.class);
 
// set the root class
Root e = update.from(Order.class);
 
// set update and where clause
update.set(&quot;amount&quot;, newAmount);
update.where(cb.greaterThanOrEqualTo(e.get(&quot;amount&quot;), oldAmount));
 
// perform update
this.em.createQuery(update).executeUpdate();
</pre></div>


<p>When executing this code, Hibernate will only perform 1 SQL UPDATE statement. It changes the <em>amount</em> of all <em>Order</em>s that fulfill the WHERE clause. Depending on the number of records this statements affects, this can provide a huge performance improvement.</p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>As you have seen, you can use several Hibernate features to detect and avoid inefficiencies and boost your application’s performance. In my experience, the most important ones are:</p>



<ul>
<li>Activating Hibernate statistics so that you can find these problems.</li>



<li>Defining the right&nbsp;<em>FetchType</em>&nbsp;in the entity mapping to avoid unnecessary queries.</li>



<li>Using Query-specific fetching to get all required information efficiently.</li>
</ul>



<p>You can get more information about these and all other Hibernate features in the courses included in the <a href="/join-persistence-hub/">Persistence Hub</a>.</p>
</div><div class="col-lg-2 col-md-0 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script></body></html>