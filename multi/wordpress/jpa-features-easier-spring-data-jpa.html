<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>5 JPA Features That Are Easier To Use with Spring Data JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>5 JPA Features That Are Easier To Use with Spring Data JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Ease of use is one of the most often stated <a href="https://thorben-janssen.com/what-is-spring-data-jpa-and-why-should-you-use-it/">benefits of Spring Data JPA over plain JPA</a>. And as long as your persistence code doesn&#8217;t get complex and you follow a few simple rules, I agree with that.</p>



<p>Spring Data JPA not only integrates JPA in your Spring stack, but it also makes using several features much easier. Here are 6 examples that are used in most applications.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#1_Executing_Basic_JPQL_Queries"><span class="toc_number toc_depth_1">1</span> 1. Executing Basic JPQL Queries</a></li><li><a href="#2_Using_DTO_projections"><span class="toc_number toc_depth_1">2</span> 2. Using DTO projections</a></li><li><a href="#3_Paginate_Your_Query_Results"><span class="toc_number toc_depth_1">3</span> 3. Paginate Your Query Results</a></li><li><a href="#4_Using_EntityGraphs"><span class="toc_number toc_depth_1">4</span> 4. Using EntityGraphs</a></li><li><a href="#5_Calling_Stored_Procedures"><span class="toc_number toc_depth_1">5</span> 5. Calling Stored Procedures</a></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">6</span> Conclusion</a></li></ul></div>
<h2><span id="1_Executing_Basic_JPQL_Queries">1. Executing Basic JPQL Queries</span></h2>



<p><a href="https://thorben-janssen.com/jpql/">JPQL</a> is JPA&#8217;s query language which enables you to define your query based on your domain instead of the table model. That requires 3 steps. You need to:</p>



<ol><li>Define and instantiate the query</li><li>Set all bind parameter values</li><li>Execute the query</li></ol>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a WHERE a.firstName = :fname&quot;, Author.class);
q.setParameter(&quot;fname&quot;, &quot;Thorben&quot;);
List&lt;Author&gt; authors = q.getResultList();</pre>



<figure class="wp-block-embed-youtube alignright wp-block-embed is-type-rich is-provider-embed-handler wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<span class="Vw20FCPDjIbxQ3mtMEvrhSZOaUyNLJuzBA1d8RkpoG5gflqn9TKeX6cY4H"><iframe title="Ultimate Guide: Derived Queries with Spring Data JPA" width="500" height="281" src="https://www.youtube.com/embed/GVeY08vUiPE?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></span>
</div></figure>



<p>Depending on the complexity of your query, you can skip most or even all of these steps with Spring Data JPA.</p>



<p>If your query isn&#8217;t too complicated and doesn&#8217;t use more than 2 bind parameters, I recommend you use the <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derived query feature</a>. Spring Data then generates the query based on the name of your repository method and executes it. You then don&#8217;t need to write any JPA- or persistence-related code.</p>



<p>Here you can see two examples. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; {

    List&lt;Author&gt; findByFirstName(String firstName);

    List&lt;Author&gt; findByBooksTitle(String title);

}</pre>



<p>When you call the <em>findByFirstName </em>method, Spring Data JPA generates a JPQL query that selects all <em>Author </em>entities with a given <em>firstName</em>. And the <em>findByBooksTitle </em>method returns all Author entities who&#8217;ve written a <em>Book </em>with a given <em>title</em>. </p>



<p>As you can see, defining and executing a basic query gets incredible easy. And you can also order your query results, use pagination, and create more complex expressions for your WHERE clause.  I explained all of that in more details in my <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">guide to derived queries with Spring Data JPA</a>.</p>







<p>As comfortable as this feature is, sooner or later, your query gets too complex to express it in a method name. You can then <a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">annotate your repository method with a </a><em><a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/">@Query</a></em><a href="https://thorben-janssen.com/spring-data-jpa-query-annotation/"> annotation</a>. Within the annotation, you can specify your JPQL query. You also need to provide a method parameter for each bind parameter used in the query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; {
 
    @Query(&quot;SELECT a FROM Author a WHERE firstName = ?1 AND lastName = ?2&quot;)
    List&lt;Author&gt; findByFirstNameAndLastName(String firstName, String lastName);
 
}</pre>



<p>When you call that method, Spring Data JPA uses the provided statement to instantiate a query, sets the bind parameter values, and maps the result. This prevents you from writing lots of boilerplate code.</p>



<h2><span id="2_Using_DTO_projections">2. Using DTO projections</span></h2>



<p>As I explained in an <a href="https://thorben-janssen.com/dto-projections/">earlier article</a>, DTO projections provide much better performance than entity projections. So, whenever you implement a read-only operation, you should prefer them over entities.</p>



<p>If you want to use <a href="https://thorben-janssen.com/dto-projections/">DTO projections</a> with plain JPA or Hibernate, you need to implement a DTO class with a constructor that expects all attributes as parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public class AuthorValue {

    private String firstName;
    private String lastName;

    public AuthorValue(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}</pre>



<p>In your JPQL or Criteria query, you can then use a <a href="https://thorben-janssen.com/hibernate-tips-select-pojo-criteria-query/">constructor expression</a> that references the constructor of your DTO class. This tells your persistence provider to call the constructor for each record in the result set and to return the created objects.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;AuthorValue&gt; q = em.createQuery(&quot;SELECT new org.thoughts.on.java.spring.data.model.AuthorValue(a.firstName, a.lastName) FROM Author a WHERE a.firstName = :fname&quot;, Author.class);
q.setParameter(&quot;fname&quot;, &quot;Thorben&quot;);
List&lt;AuthorValue&gt; authors = q.getResultList();</pre>



<p>Spring Data JPA can handle most of these tasks for you. You just need to define an interface and use it as the return type of your repository method. Spring Data JPA then takes care of the rest.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorValueIntf {

    String getFirstName();
    void setFirstName(String firstName);

    String getLastName();
    void setLastName(String lastName);
}</pre>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; {

    List&lt;AuthorValueIntf&gt; findByFirstName(String firstName);

}</pre>



<h2><span id="3_Paginate_Your_Query_Results">3. Paginate Your Query Results</span></h2>



<p>Similar to SQL, you can decide to fetch only a subset of your query results with JPA. You can do that by <a href="https://thorben-janssen.com/hibernate-tips-use-pagination-jpql/">calling the </a><em><a href="https://thorben-janssen.com/hibernate-tips-use-pagination-jpql/">setMaxResults</a></em><a href="https://thorben-janssen.com/hibernate-tips-use-pagination-jpql/"> and </a><em><a href="https://thorben-janssen.com/hibernate-tips-use-pagination-jpql/">setFirstResult</a></em><a href="https://thorben-janssen.com/hibernate-tips-use-pagination-jpql/"> methods</a> on the <em>Query</em> interface.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Author&gt; q = em.createQuery(&quot;SELECT a FROM Author a&quot;, Author.class);
q.setMaxResults(5)								q.setFirstResult(0)
List&lt;Author&gt; authors = q.getResultList();</pre>



<p>When your user steps from page to page, you need to calculate the value you provide to the <em>setFirstResult</em> method for each page.</p>



<p>Spring Data JPA&#8217;s <em>Pageable</em> interface makes that a little bit easier. You can add it as a parameter to your repository method, to activating pagination for your query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface BookRepository extends JpaRepository&amp;lt;Book, Long&amp;gt; {
 
    Page&lt;Book&gt; findAll(Pageable pageable);
 
}</pre>



<p>When you instantiate a new <em>Pageable</em> object, you just need to define which page you want to get and how many records are on a page. Spring Data JPA then calculate the correct LIMIT and OFFSET values for you.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Pageable pageable = PageRequest.of(0, 10);
Page&lt;Book&gt; b = bookRepository.findAll(pageable);</pre>



<h2><span id="4_Using_EntityGraphs">4. Using EntityGraphs</span></h2>



<figure class="wp-block-embed-youtube alignright wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<span class="T0uHkY53HlNMP2K9Ttx7AaiDjv8zSGQMjtVIUBdLzBROXoRYmg4XbSO6a5Eh6KqFoqm4wx8r2uZ"><iframe title="5 ways to initialize lazy associations and when to use them" width="500" height="281" src="https://www.youtube.com/embed/Dr5Qn6NC-3Y?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></span>
</div></figure>



<p>An <a href="https://thorben-janssen.com/jpa-21-entity-graph-part-1-named-entity/">EntityGraph</a> provides an easy and reusable way to <a href="https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/">initialize required entity associations</a> within your query. Instead of executing an additional query for each entity association, which is known as the <a href="https://thorben-janssen.com/free-mini-course-find-fix-n1-select-issues-hibernate/">n+1 select issue</a>, Hibernate then gets all required information with just one query.</p>



<p>Defining and using such a graph with JPA isn&#8217;t complicated, but it requires multiple steps. You first need to use a <em>@NamedEntityGraph</em> annotation or the <em>EntityGraph</em> API to define the graph.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@Table(name = &quot;purchaseOrder&quot;)
@NamedEntityGraph(name = &quot;graph.Order.items&quot;, 
               attributeNodes = @NamedAttributeNode(value = &quot;items&quot;, subgraph = &quot;items&quot;), 
               subgraphs = @NamedSubgraph(name = &quot;items&quot;, attributeNodes = @NamedAttributeNode(&quot;product&quot;)))
public class Order { ... }</pre>



<p>In the second step, you need to instantiate the graph and add it to your query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">EntityGraph graph = this.em.getEntityGraph(&quot;graph.Order.items&quot;);

Map hints = new HashMap();
hints.put(&quot;javax.persistence.fetchgraph&quot;, graph);

return this.em.find(Order.class, orderId, hints);</pre>



<p>Spring Data JPA makes this a little bit easier. When you annotate your repository method with <em>@EntityGraph</em>, you can: </p>



<ul><li>Reference an existing <em>@NamedEntityGraph</em> by setting its name as the value attribute.</li><li>Define an ad-hoc graph using the <em>attributePaths </em>attribute of the <em>@EntityGraph</em> annotation.</li></ul>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @EntityGraph(value = &quot;graph.Order.items&quot;, type = EntityGraphType.LOAD)
    List&lt;Order&gt; findByOrderNumber(String orderNumber);

}</pre>



<h2><span id="5_Calling_Stored_Procedures">5. Calling Stored Procedures</span></h2>



<p>JPA provides 2 ways to call a stored procedure. You can <a href="https://thorben-janssen.com/call-stored-procedures-jpa/">use a </a><em><a href="https://thorben-janssen.com/call-stored-procedures-jpa/">@NamedStoredProcedureQuery</a></em><a href="https://thorben-janssen.com/call-stored-procedures-jpa/"> annotation</a> to define your stored procedure call at build time. And if you want to create an ad-hoc stored procedure call, you can <a href="https://thorben-janssen.com/call-stored-procedures-jpa-part-2/">use the </a><em><a href="https://thorben-janssen.com/call-stored-procedures-jpa-part-2/">StoredProcedureQuery</a></em><a href="https://thorben-janssen.com/call-stored-procedures-jpa-part-2/"> API</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@NamedStoredProcedureQuery(
	name = &quot;calculate&quot;, 
	procedureName = &quot;calculate&quot;, 
	parameters = { 
		@StoredProcedureParameter(mode = ParameterMode.IN, type = Double.class, name = &quot;x&quot;), 
		@StoredProcedureParameter(mode = ParameterMode.IN, type = Double.class, name = &quot;y&quot;), 
		@StoredProcedureParameter(mode = ParameterMode.OUT, type = Double.class, name = &quot;sum&quot;)
	}
)</pre>



<p>Spring Data JPA makes calling a <em>@NamedStoredProcedureQuery</em> very easy.</p>



<p>With plain JPA, you need to instantiate the query, set the bind parameter values, and execute the query. Almost all of that is very repetitive boilerplate code.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">StoredProcedureQuery query = this.em.createNamedStoredProcedureQuery(&quot;calculate&quot;);
query.setParameter(&quot;x&quot;, 1.23d);
query.setParameter(&quot;y&quot;, 4.56d);
query.execute();
Double sum = (Double) query.getOutputParameterValue(&quot;sum&quot;);</pre>



<p>Similar to the previously shown <a href="https://thorben-janssen.com/jpql/">JPQL queries</a>, Spring Data JPA takes care of the boilerplate code. You just need to annotate your repository method with <em>@Procedure</em> and provide method parameters with the same names as your bind parameters.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {

    @Procedure(name = &quot;calculate&quot;)
    Double calculateOrderValue(Double x, Double y);

}</pre>



<p>When you call the repository method, Spring Data JPA uses this information to instantiate the <em>@NamedStoredProcedureQuery</em>, set the bind parameter values, execute the query, and return the result.</p>







<h2><span id="Conclusion">Conclusion</span></h2>



<p>The JPA specification defines most of the features provided by Spring Data JPA. On top of that, Spring Data JPA adds several usability features so that you can focus on your business instead of your persistence code.</p>



<p>As you&#8217;ve seen in this article, JPA requires a lot of repetitive boilerplate code to execute a query, implement custom projections, and define query-specific association fetching. </p>



<p>Spring Data JPA takes care of that. You just need to add an annotation and Spring Data JPA provides the boilerplate code.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>