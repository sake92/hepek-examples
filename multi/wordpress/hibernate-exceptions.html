<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Common Hibernate Exceptions Every Developer Must Know</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Common Hibernate Exceptions Every Developer Must Know</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Every framework has a set of exceptions that indicate common error scenarios. Understanding them will help you turn a task that could drag along for days into a quickly-implemented feature. When working with Hibernate, they tell you about issues with your database queries, mapping mistakes, and problems during write operations.</p>



<p>In this article, I want to show you the most common exceptions and explain how you can avoid or fix them.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Query-Related_Exceptions"><span class="toc_number toc_depth_1">1</span> Query-Related Exceptions</a><ul><li><a href="#NonUniqueResultException"><span class="toc_number toc_depth_2">1.1</span> NonUniqueResultException</a></li><li><a href="#QuerySyntaxException"><span class="toc_number toc_depth_2">1.2</span> QuerySyntaxException</a></li><li><a href="#SQLGrammarException"><span class="toc_number toc_depth_2">1.3</span> SQLGrammarException</a></li><li><a href="#LazyInitializationException"><span class="toc_number toc_depth_2">1.4</span> LazyInitializationException</a></li><li><a href="#MultipleBagFetchException"><span class="toc_number toc_depth_2">1.5</span> MultipleBagFetchException</a></li></ul></li><li><a href="#Mapping-Related_Exceptions"><span class="toc_number toc_depth_1">2</span> Mapping-Related Exceptions</a><ul><li><a href="#MappingException_The_Increment_Size_of_the_author_seqence_Sequence_Is_Set_to_50_in_the_Entity_Mapping_While_the_Associated_Database_Sequence_Increment_Size_Is_1"><span class="toc_number toc_depth_2">2.1</span> MappingException: The Increment Size of the [author_seqence] Sequence Is Set to [50] in the Entity Mapping While the Associated Database Sequence Increment Size Is [1]</a></li></ul></li><li><a href="#Update-Related_Exceptions"><span class="toc_number toc_depth_1">3</span> Update-Related Exceptions</a><ul><li><a href="#OptimisticLockException"><span class="toc_number toc_depth_2">3.1</span> OptimisticLockException</a></li><li><a href="#PersistentObjectException_Detached_Entity_Passed_to_Persist"><span class="toc_number toc_depth_2">3.2</span> PersistentObjectException: Detached Entity Passed to Persist</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">4</span> Conclusion</a></li></ul></div>
<h2><span id="Query-Related_Exceptions">Query-Related Exceptions</span></h2>



<p>These are the most common Hibernate exceptions. Sometimes, they are caused by a simple typo in your statement or because you called the wrong&nbsp;<em>Query</em>&nbsp;interface method. However, they can also indicate potential performance issues or data inconsistencies.</p>



<h3><span id="NonUniqueResultException">NonUniqueResultException</span></h3>



<p>All JPA implementations throw the&nbsp;<em>NonUniqueResultException&nbsp;</em>if you call the&nbsp;<em>getSingleResult&nbsp;</em>method on a&nbsp;<em>Query&nbsp;</em>interface and the executed query returns more than one record.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">javax.persistence.NonUniqueResultException: query did not return a unique result: 2
	at org.hibernate.internal.ExceptionConverterImpl.convert(ExceptionConverterImpl.java:128)
	at org.hibernate.query.internal.AbstractProducedQuery.getSingleResult(AbstractProducedQuery.java:1588)
	...
</pre>



<p>The <em>NonUniqueResultException</em> most often occurs because:</p>



<ul><li>You intentionally wrote a query that returns multiple records and tried executing it by calling the <em>getSingleResult()</em> instead of the <em>getResultList()</em> method. To be honest, that happens to me quite regularly. Luckily, it’s very quick and easy to fix by calling the&nbsp;<em>getResultList()</em>&nbsp;method.</li><li>You wanted to create a query that returns only one record, but the WHERE clause isn&#8217;t as restrictive as you thought. In that case, please check my <a href="https://thorben-janssen.com/jpql/">Guide to JPQL</a>. It tells you everything you need to know to improve your query.</li><li>You wrote a query that was supposed to return only one record and you stumbled upon inconsistent data. If that happens, then it&#8217;s hopefully just some artificially created test data. But, in any case, you should double-check your business logic and add a unique constraint to your table model. </li></ul>



<h3><span id="QuerySyntaxException">QuerySyntaxException</span></h3>



<p>If Hibernate throws a <em>QuerySyntaxException</em>, you have made a mistake in your <a href="https://thorben-janssen.com/jpql/">JPQL query</a>. In most cases, the mistake will be a simple typo in one of JPQL&#8217;s reserved keywords. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book book = entityManager
					.createQuery(&quot;SELECT b FROM Book b LFET JOIN b.author a WHERE a.id=:id&quot;, Book.class)
					.setParameter(&quot;id&quot;, id)
					.getSingleResult();</pre>



<p>As you can see in the following log message, Hibernate tells you which part of the query it didn&#8217;t understand. In this example, I misspelled the word <em>LEFT </em>in my <em>LEFT JOIN</em> clause.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: 
unexpected token: LFET near line 1, column 49 
[SELECT b FROM com.thorben.janssen.entity.Book b LFET JOIN b.author a WHERE a.id=:id]</pre>



<h3><span id="SQLGrammarException">SQLGrammarException</span></h3>



<p>An <em>SqlGrammarException </em>is very similar to a <em>QuerySyntaxException</em>. It indicates a mistake in a <a href="https://thorben-janssen.com/jpa-native-queries/">native SQL statement</a>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Book book = (Book) entityManager
					.createNativeQuery(&quot;SELECT b FROM Book b LFET JOIN Author a on b.author_id = a.id WHERE a.id=:id&quot;, Book.class)
					.setParameter(&quot;id&quot;, id)
					.getSingleResult();</pre>



<p>Unfortunately, Hibernate&#8217;s exception doesn&#8217;t provide a lot of information about the actual error. It only tells you that it was unable to extract the <em>ResultSet</em>. But, if you take a look at the end of the stack trace, you should find the exception thrown by your JDBC driver. It usually tells you why the query failed.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">javax.persistence.PersistenceException: org.hibernate.exception.SQLGrammarException: could not extract ResultSet
	... 
Caused by: org.hibernate.exception.SQLGrammarException: could not extract ResultSet
	... 
Caused by: org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;LFET&quot;
  Position: 22</pre>



<h3><span id="LazyInitializationException">LazyInitializationException</span></h3>



<p>The <em><a href="https://thorben-janssen.com/lazyinitializationexception/">LazyInitializationException</a></em> might not look like a query-related exception because it happens much later. Hibernate throws it if you try to initialize a lazily fetched association without an active Hibernate <em>Session</em>. This usually happens in your UI layer after your backend committed the transaction and closed the <em>Session</em>. Even though it might not look like it, it&#8217;s caused by a query that didn&#8217;t fetch the required association.</p>



<p>As you can see in the message below, Hibernate tells you which association it wasn&#8217;t able to initialize.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: 
com.thorben.janssen.entity.Author.books, could not initialize proxy - no Session</pre>



<p>You can fix this exception in multiple ways. The easiest and <a href="https://thorben-janssen.com/5-ways-to-initialize-lazy-relations-and-when-to-use-them/">most commonly used solution</a> is a JOIN FETCH clause. You can use it in your JPQL query to tell Hibernate to initialize the referenced association.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">		List&lt;Author&gt; authors = entityManager.createQuery(&quot;SELECT a FROM Author a JOIN FETCH a.books&quot;, Author.class).getResultList();
</pre>



<h3><span id="MultipleBagFetchException">MultipleBagFetchException</span></h3>



<p>If you model your to-many associations as&nbsp;<em>java.util.List</em>s and try to initialize a number of them using a JOIN FETCH clause, Hibernate will throw a&nbsp;<em>MultipleBagFetchException</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">List&lt;Book&gt; books = entityManager.createQuery(&quot;&quot;&quot;
	SELECT b 
	FROM Book b 
		JOIN FETCH b.authors a 
		JOIN FETCH b.reviews r&quot;&quot;&quot;, 
	Book.class).getResultList();
</pre>



<p>As I explained in more detail in a <a href="https://thorben-janssen.com/fix-multiplebagfetchexception-hibernate/">previous article</a>, you can fix this exception in two ways:</p>



<p>1. You can change the attribute type to a <em>java.util.Set</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {
	
	@ManyToMany
	private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();
	
	@OneToMany(mappedBy = &quot;book&quot;)
	private Set&lt;Review&gt; reviews = new HashSet&lt;Review&gt;();
	
	...
}</pre>



<p>2. You can use multiple queries that use only one JOIN FETCH clause each. This approach works because Hibernate ensures that a <em>Session </em>contains only one entity object for each database record. If you select the same one with different fetching behavior, Hibernate will merge them in memory.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Book&gt; q = em.createQuery(&quot;&quot;&quot;
		SELECT DISTINCT b
		FROM Book b 
			JOIN FETCH b.authors a
		WHERE b.id = 1&quot;&quot;&quot;,
		Book.class);
q.setHint(QueryHints.PASS_DISTINCT_THROUGH, false);
List&lt;Book&gt; books = q.getResultList();

q = em.createQuery(&quot;&quot;&quot;
		SELECT DISTINCT b
		FROM Book b 
			JOIN FETCH b.reviews r
		WHERE b.id = 1&quot;&quot;&quot;,
		Book.class);
q.setHint(QueryHints.PASS_DISTINCT_THROUGH, false);
books = q.getResultList();
</pre>



<h2><span id="Mapping-Related_Exceptions">Mapping-Related Exceptions</span></h2>



<p>I will keep this section short because mapping-related exceptions are rare. That&#8217;s mostly because mapping is defined once and used during the entire project.</p>



<h3><span id="MappingException_The_Increment_Size_of_the_author_seqence_Sequence_Is_Set_to_50_in_the_Entity_Mapping_While_the_Associated_Database_Sequence_Increment_Size_Is_1">MappingException: The Increment Size of the [author_seqence] Sequence Is Set to [50] in the Entity Mapping While the Associated Database Sequence Increment Size Is [1]</span></h3>



<p>If you use a <a href="https://thorben-janssen.com/jpa-generate-primary-keys/">database sequence to generate your primary key values</a> and define a <em>@SequenceGenerator</em>, you might get the following exception:</p>



<pre class="wp-block-preformatted brush: java; gutter: true">MappingException: The increment size of the [author_seqence] sequence 
is set to [50] in the entity mapping while the associated database sequence 
increment size is [1].</pre>



<p>Hibernate throws this exception because it provides an optimization based on the default <em>allocationSize </em>of the <em>@SequenceGenerator</em>. Based on that default setting, the database sequence should get incremented by 50 every time you request a new value. Hibernate then uses the value from the sequence and increments it 49 times internally before requesting another value. This drastically reduces the number of executed JDBC statements.</p>



<p>During the deployment of your persistence layer, Hibernate checks if the referenced database sequence gets incremented by the defined <em>allocationSize</em>. If that&#8217;s not the case, it throws a <em>MappingException</em>.</p>



<p>I recommend fixing this exception by increasing the step size on your database sequence. It enables you to use Hibernate’s optimization to improve the performance of your insert operations. If you cannot change the database sequence, you need to set the&nbsp;<em>allocationSize</em>&nbsp;of the&nbsp;<em>@SequenceGenerator</em>&nbsp;to one.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;author_seq&quot;)
@SequenceGenerator(name = &quot;author_seq&quot;, allocationSize = 1)
private Long id;</pre>



<h2><span id="Update-Related_Exceptions">Update-Related Exceptions</span></h2>



<p>Hibernate throws this kind of exception to inform you about problems during write operations. The two most common ones are the OptimisticLockException and the PersistentObjectException. While the first one is expected to occur at runtime, the second one is always an implementation error.</p>



<h3><span id="OptimisticLockException">OptimisticLockException</span></h3>



<p>JPA and Hibernate provide two build-in mechanisms to manage concurrent updates. One of them is called optimistic locking. It causes an <em>OptimisticLockException</em> whenever two or more transactions try to update the same database record at the same time. That lets all except the first transaction fail and prevents the concurrent modification of the record.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">javax.persistence.RollbackException: 
Error while committing the transaction
	...
Caused by: javax.persistence.OptimisticLockException: 
Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [com.thorben.janssen.entity.Book#4]
	...
Caused by: org.hibernate.StaleObjectStateException: 
Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [com.thorben.janssen.entity.Book#4]
	...</pre>



<p>Optimistic and pessimistic locking are easy and complex at the same time, but that&#8217;s a whole other topic. If you want to learn more about it, please join my <a href="/hibernate-performance-tuning-online-training-wst/">Hibernate Performance Tuning Online Training</a>.</p>



<p>Technically, there are a few options for fixing an <em>OptimisticLockException</em>. But realistically, all of them require you to merge the operations performed in the parallel transactions. The best and most reliable way to do that is to show an error message to the user when the exception occurs. The user can then find the differences between both changes, resolve errors or inconsistencies, and perform another update.</p>



<h3><span id="PersistentObjectException_Detached_Entity_Passed_to_Persist">PersistentObjectException: Detached Entity Passed to Persist</span></h3>



<p>There are two main scenarios in which Hibernate throws this exception. </p>



<p>The first happens when you configure a primary key generation strategy for an entity and set the primary key value programmatically before persisting a new entity. You can easily fix that by removing the code that sets the primary key value. If you&#8217;re using <a href="/access-strategies-in-jpa-and-hibernate">field-based access</a>, you should also remove the setter method for the primary key attribute. This prevents you from accidentally setting that attribute in the future.</p>



<p>The second scenario happens when you call the persist method of the EntityManager with a detached entity. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">javax.persistence.PersistenceException: org.hibernate.PersistentObjectException: detached entity passed to persist: com.thorben.janssen.entity.Author</pre>



<p>This is usually the case because you got an entity object from a client application and tried to persist it. In this case, you can fix the exception by calling the <a href="https://thorben-janssen.com/persist-save-merge-saveorupdate-whats-difference-one-use/">merge method on the EntityManager</a>.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>If you&#8217;re using a framework to implement your application, you should be familiar with its most common exceptions. Hibernate is a complex and powerful framework. So, it&#8217;s no surprise that you need to be familiar with a bunch of exceptions. </p>



<p>Most of them are query-related because querying data is highly flexible and the most used part of the framework. The good news is that all of these exceptions include a good description of the error so that you can easily fix it.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>