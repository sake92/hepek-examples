<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Lombok &amp; Hibernate: How to Avoid Common Pitfalls</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Lombok &amp; Hibernate: How to Avoid Common Pitfalls</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p><a href="https://projectlombok.org/">Lombok</a> is a popular framework among Java developers because it generates repetitive boilerplate code like getter and setter methods, equals and hashCode methods, and the default constructor. All you need to do is add a few annotations to your class and Lombok will add the required code at compile time. This works reasonably well for normal classes, but it introduces a few dangerous pitfalls if you use it for your Hibernate entities.</p>



<p>To avoid these pitfalls, I recommend NOT using Lombok for your entity classes. If you use the code generator features of your IDE, it will take you less than a minute to create a much better implementation of these methods yourself. </p>



<p>So, let&#8217;s take a look at some of Lombok&#8217;s most popular annotations and why you need to be careful when using them with Hibernate. </p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#A_Basic_Domain_Model"><span class="toc_number toc_depth_1">1</span> A Basic Domain Model</a></li><li><a href="#3_Lombok_Annotations_You_Need_to_Avoid"><span class="toc_number toc_depth_1">2</span> 3 Lombok Annotations You Need to Avoid</a><ul><li><a href="#Don8217t_Use_EqualsAndHashCode"><span class="toc_number toc_depth_2">2.1</span> Don&#8217;t Use @EqualsAndHashCode</a></li><li><a href="#Be_Careful_with_ToString"><span class="toc_number toc_depth_2">2.2</span> Be Careful with @ToString</a></li><li><a href="#Avoid_Data"><span class="toc_number toc_depth_2">2.3</span> Avoid @Data</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="A_Basic_Domain_Model">A Basic Domain Model</span></h2>



<p>In all of the following examples, I will use this very basic domain model. The Order entity class represents the order in an online store. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;

	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	public Long getId() {
		return id;
	}
	public String getCustomer() {
		return customer;
	}

	public void setCustomer(String customer) {
		this.customer = customer;
	}

	public Set&lt;OrderPosition&gt; getPositions() {
		return positions;
	}

	public void setPositions(Set&lt;OrderPosition&gt; positions) {
		this.positions = positions;
	}

	@Override
	public int hashCode() {
		return 42;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Order other = (Order) obj;
		if (id == null) {
			return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return &quot;Order [customer=&quot; + customer + &quot;, id=&quot; + id + &quot;]&quot;;
	}
	
}</pre>



<p>For each <em>Order</em>, I want to store the ID, the name of the customer, and one or more order positions. These are modeled by the <em>OrderPosition </em>class. It maps the ID, the name of the product, the ordered quantity, and a reference to the Order.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class OrderPosition {
    
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;

    private String product;

    private int quantity;

    @ManyToOne(fetch = FetchType.LAZY)
    private Order order;

    public Long getId() {
        return id;
    }

    public String getProduct() {
        return product;
    }

    public void setProduct(String product) {
        this.product = product;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public Order getOrder() {
        return order;
    }

    public void setOrder(Order order) {
        this.order = order;
    }

    @Override
    public int hashCode() {
        return 42;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        OrderPosition other = (OrderPosition) obj;
        if (id == null) {
            return false;
        } else if (!id.equals(other.id))
            return false;
        return true;
    }
}</pre>



<h2><span id="3_Lombok_Annotations_You_Need_to_Avoid">3 Lombok Annotations You Need to Avoid</span></h2>



<p>Lombok is an incredibly popular framework despite having few annotations. This is because it addresses developer pain points. </p>



<p>However, Lombok doesn&#8217;t work well with many other frameworks. I recommend you avoid three of its most commonly used annotations.</p>



<h3><span id="Don8217t_Use_EqualsAndHashCode">Don&#8217;t Use <em>@EqualsAndHashCode</em></span></h3>



<p>The necessity of implementing the equals() and hashCode() methods for entity classes is often discussed amongst developers. This seems like a complicated and important topic because of the need to fulfill both the contracts defined by the Java language specifications and rules defined by the JPA specification.</p>



<p>But, it&#8217;s actually a lot simpler than it might seem. As I explained in great detail in my <a href="https://thorben-janssen.com/ultimate-guide-to-implementing-equals-and-hashcode-with-hibernate/">guide to implementing equals() and hashCode()</a>, your hashCode() method should always return a fixed value, for example 42. In the equals() method, you should only compare the type of the objects and their primary key values. If at least one of the primary keys is null, the equals method has to return <em>false</em>.</p>



<p>If you don&#8217;t want to implement these methods yourself, you can annotate your class with Lombok&#8217;s <em>@EqualsAndHashCode </em>annotation. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@EqualsAndHashCode
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;

	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();
	
	...
}</pre>



<p>Lombok then generates the following  <em>equals()</em> and a <em>hashCode()</em> methods. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;
	
	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	...

	@Override
	public boolean equals(final Object o) {
		if (o == this) return true;
		if (!(o instanceof Order)) return false;
		final Order other = (Order) o;
		if (!other.canEqual((Object) this)) return false;
		final Object this$id = this.getId();
		final Object other$id = other.getId();
		if (this$id == null ? other$id != null : !this$id.equals(other$id)) return false;
		final Object this$customer = this.getCustomer();
		final Object other$customer = other.getCustomer();
		if (this$customer == null ? other$customer != null : !this$customer.equals(other$customer)) return false;
		final Object this$positions = this.getPositions();
		final Object other$positions = other.getPositions();
		if (this$positions == null ? other$positions != null : !this$positions.equals(other$positions)) return false;
		return true;
	}

	protected boolean canEqual(final Object other) {
		return other instanceof Order;
	}

	@Override
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		final Object $id = this.getId();
		result = result * PRIME + ($id == null ? 43 : $id.hashCode());
		final Object $customer = this.getCustomer();
		result = result * PRIME + ($customer == null ? 43 : $customer.hashCode());
		final Object $positions = this.getPositions();
		result = result * PRIME + ($positions == null ? 43 : $positions.hashCode());
		return result;
	}
}</pre>



<p>If you take a closer look at both methods, you can see that they don&#8217;t follow my previous recommendations. This causes multiple issues.</p>



<p>Let&#8217;s start with the most obvious one: both methods include all non-final attributes of the class. You can change that by setting the <em>onlyExplicitlyIncluded </em>attribute of the <em>@EqualsAndHashCode</em> annotation to <em>true</em> and annotating the primary key attribute with <em>@EqualsAndHashCode.Include</em>. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	@EqualsAndHashCode.Include
	private Long id;

	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();
	
	...
}</pre>



<p>Lombok then only includes the primary key value in the hash code calculation and equals check.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;

	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	public Long getId() {
		return id;
	}

	public String getCustomer() {
		return customer;
	}

	public void setCustomer(String customer) {
		this.customer = customer;
	}

	public Set&lt;OrderPosition&gt; getPositions() {
		return positions;
	}

	public void setPositions(Set&lt;OrderPosition&gt; positions) {
		this.positions = positions;
	}

	@Override
	public String toString() {
		return &quot;Order [customer=&quot; + customer + &quot;, id=&quot; + id + &quot;]&quot;;
	}

	@Override
	public boolean equals(final Object o) {
		if (o == this) return true;
		if (!(o instanceof Order)) return false;
		final Order other = (Order) o;
		if (!other.canEqual((Object) this)) return false;
		final Object this$id = this.getId();
		final Object other$id = other.getId();
		if (this$id == null ? other$id != null : !this$id.equals(other$id)) return false;
		return true;
	}

	protected boolean canEqual(final Object other) {
		return other instanceof Order;
	}

	@Override
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		final Object $id = this.getId();
		result = result * PRIME + ($id == null ? 43 : $id.hashCode());
		return result;
	}
}</pre>



<p>That will not fix all issues. Your equals() method should return false if the primary key value of both entity objects is <em>null</em>. But Lombok&#8217;s <em>equals()</em> method returns <em>true</em>. Because of that, you can&#8217;t add two new entity objects to a <em>Set</em>. In the example shown above, that means that you can&#8217;t add two new <em>OrderPosition</em> objects to an <em>Order</em>. You should, therefore, avoid Lombok&#8217;s <em>@EqualsAndHashCode</em> annotation.</p>



<h3><span id="Be_Careful_with_ToString">Be Careful with <em>@ToString</em></span></h3>



<p>If you annotate your entity class with Lombok&#8217;s <em>@ToString</em> annotation, Lombok generates a <em>toString()</em> method. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@ToString
public class Order { ... }</pre>



<p>The returned <em>String </em>contains all non-final attributes of that class.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;
	
	private String customer;
	
	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	...

	@Override
	public String toString() {
		return &quot;Order(id=&quot; + this.getId() + &quot;, customer=&quot; + this.getCustomer() + &quot;, positions=&quot; + this.getPositions() + &quot;)&quot;;
	}
}</pre>



<p>Using that annotation with an entity class is risky because it&#8217;s possible that not all attributes are being initialized. If you set the <em><a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">FetchType</a> </em>of an association to <em>LAZY</em> or use the default fetching of a <a href="/ultimate-guide-association-mappings-jpa-hibernate/">many-to-many association</a>, Hibernate will try to read the association from the database. If you&#8217;re doing this within an active Hibernate <em>Session</em>, this will cause an additional query and slow down your application. Worse yet is if you do it without an active Hibernate <em>Session</em>. In that case, Hibernate throws a <em><a href="https://thorben-janssen.com/lazyinitializationexception/">LazyInitializationException</a></em>.</p>



<p>You can avoid that by excluding all lazily fetched associations from your <em>toString()</em> method. To do that, you need to annotate these attributes with <em>@ToString.Exclude</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@ToString
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;

	private String customer;

	@OneToMany(mappedBy = &quot;order&quot;)
	@ToString.Exclude
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	...
}</pre>



<p>As you can see in the code snippet, Lombok&#8217;s <em>toString()</em> method no longer includes the <em>orderPosition</em> attribute and avoids all lazy loading issues. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Order {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	private Long id;
	
	private String customer;
	
	@OneToMany(mappedBy = &quot;order&quot;)
	private Set&lt;OrderPosition&gt; positions = new HashSet&lt;&gt;();

	public Long getId() {
		return id;
	}

	public String getCustomer() {
		return customer;
	}

	public void setCustomer(String customer) {
		this.customer = customer;
	}

	public Set&lt;OrderPosition&gt; getPositions() {
		return positions;
	}

	public void setPositions(Set&lt;OrderPosition&gt; positions) {
		this.positions = positions;
	}

	@Override
	public String toString() {
		return &quot;Order(id=&quot; + this.getId() + &quot;, customer=&quot; + this.getCustomer() + &quot;)&quot;;
	}
}</pre>



<p>But for most entities, this approach:</p>



<ul><li>Adds several <em>@ToString.Exclude</em> annotations to your class, which makes it harder to read;</li><li>Introduces the risk that every new lazily fetched association might break your application; and </li><li>Requires more effort than using your IDE to generate the <em>toString() </em>method.</li></ul>



<h3><span id="Avoid_Data">Avoid <em>@Data</em></span></h3>



<p>Lombok’s&nbsp;<em>@Data</em>&nbsp;annotation acts as a shortcut for @ToString, <em>@EqualsAndHashCode</em>, and <em>@RequiredArgsConstructor</em> annotations on your class; @Getter annotations on all fields; and @Setter annotations on all non-final fields.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@Data
public class Order { ... }</pre>



<p>So, if you build the Order class in the previous code snippet, Lombok generates getter and setter methods for all attributes and the methods <em>equals()</em>, <em>hashCode()</em>, and <em>toString()</em>.</p>



<p>As I explained earlier in this article, Lombok&#8217;s equals() method isn&#8217;t suitable for entity classes and you need to be careful when using the <em>@ToString</em> annotation. Because of this, you shouldn&#8217;t use Lombok&#8217;s <em>@Data</em> annotation on your entity classes. On the other hand, you could use it for your <a href="https://thorben-janssen.com/dto-projections/">DTO classes</a>.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Entity classes have different requirements than plain Java classes. That makes Lombok&#8217;s generated <em>equals()</em> and <em>hashCode()</em> methods unusable and its <em>toString()</em> method risky to use.</p>



<p>You could, of course, use other Lombok annotations, like <em>@Getter</em>, <em>@Setter</em>, <em>@Builder</em>. I don&#8217;t think that these annotations provide a lot of value on an entity class. Your IDE can easily generate getter and setter methods for your attributes, and a good implementation of the <a href="https://thorben-janssen.com/builder-pattern-hibernate/">builder pattern</a> requires too much domain knowledge. </p>



<p>The bottom line is that you can use the <em>@Getter</em>, <em>@Setter,</em> and <em>@Builder</em> annotation without breaking your application. The only Lombok annotations you need to avoid are <em>@Data</em>, <em>@ToString</em>, and <em>@EqualsAndHashCode</em>.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>