<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Hibernate’s Naming Strategies</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.4.1/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Hibernate’s Naming Strategies</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8">
<p>JPA and Hibernate provide a default mapping that maps each entity class to a database table with the same name. Each of its attributes gets mapped to a column with the same. But what if you want to change this default, e.g., because it doesn&#8217;t match your company&#8217;s naming conventions?</p>



<p>You can, of course, specify the table name for each entity and the column name for each attribute. That requires a <a href="https://thorben-janssen.com/hibernate-tips-define-schema-table-names/"><em>@Table</em> annotation on each class</a> and a <em>@Column</em> annotation on each attribute. This is called explicit naming.</p>



<p>That&#8217;s a good approach if you want to change the mapping for one attribute. But doing that for lots of attributes requires a lot of work. Adapting Hibernate&#8217;s naming strategy is then often a better approach.</p>



<p>In this article, I will show you how to use it to adjust the mapping of all entities and attributes. But before we do that, we first need to talk about the difference between Hibernate&#8217;s logical and physical naming strategy.</p>



<h2 class="wp-block-heading">A 2-step approach</h2>



<p>Hibernate splits the mapping of the entity or attribute name to the table or column name into 2 steps:</p>



<ol>
<li>It first determines&nbsp;the logical name of an entity or attribute. You can explicitly set the logical name using the <a href="https://thorben-janssen.com/key-jpa-hibernate-annotations/"><em>@Table</em> and <em>@Column</em> annotations</a>. If you don&#8217;t do that, Hibernate will use one of its implicit naming strategies.</li>



<li>It then maps the logical name to a physical name. By default, Hibernate uses the logical name as the physical name. But you can also implement a&nbsp;<em>PhysicalNamingStrategy&nbsp;</em>that maps the logical name to a physical one that follows your internal naming convention. Or, since Hibernate 5.5.4, you can activate Hibernate&#8217;s <em>CamelCaseToUnderscoresNamingStrategy</em>.</li>
</ol>



<p>So, why does Hibernate differentiate between a logical and a physical naming strategy, but the JPA specification doesn&#8217;t?</p>



<p>JPA&#8217;s approach works, but if you take a closer look at it, you recognize that Hibernate&#8217;s approach provides more flexibility. By splitting the process into 2 steps, Hibernate allows you to implement a conversion that gets applied to all attributes and classes. </p>



<p>If your naming conventions, for example, require you to ad &#8220;_TBL&#8221; to all table names, you can do that in your <em>PhysicalNamingStrategy</em>. It then doesn&#8217;t matter if you explicitly specify the table name in a <em>@Table</em> annotation or if you do it implicitly based on the entity name. In both cases, Hibernate will add &#8220;_TBL&#8221; to the end of your table name. </p>



<p>Because of the added flexibility, I like Hibernate&#8217;s approach a little better.</p>



<h2 class="wp-block-heading">Logical naming strategy</h2>



<p>As explained earlier, you can either define the logical name explicitly or implicitly. Let&#8217;s take a look at both options.</p>



<h3 class="wp-block-heading" id="explicitNamingStrategy">Explicit naming strategy</h3>



<p>The explicit naming strategy is very easy to use. You probably already used it yourself. The only thing you need to do is annotate your entity class with <em>@Table</em> or your entity attribute with <em>@Column</em> and provide your preferred name as a value to the name attribute.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@Table(name = "AUTHORS")
public class Author {

    @Column(name = "author_name")
    private String name;

    ...
}</pre>



<p>If you then use this entity in your code and activate the <a href="https://thorben-janssen.com/hibernate-logging-guide/">logging of SQL statements</a>, you can see that Hibernate uses the provided names instead of the default ones.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">15:55:52,525 DEBUG [org.hibernate.SQL] - insert into AUTHORS (author_name, version, id) values (?, ?, ?)
</pre>



<h3 class="wp-block-heading">Implicit naming strategy</h3>



<p>If you don&#8217;t set the table or column name in an annotation, Hibernate uses one of its implicit naming strategies. You can choose between 4 different naming strategies and 1 default strategy:</p>



<ul>
<li><strong>default</strong><br>By default, Hibernate uses the implicit naming strategy defined by the JPA specification. This value is an alias for <strong>jpa</strong>.</li>



<li><strong>jpa</strong><br>This is the naming strategy defined by the JPA 2.0 specification.<br>The logical name of an entity class is either the name provided in the <em>@Entity</em> annotation or the unqualified class name. For basic attributes, it uses the name of the attributes as the logical name. To get the logical name of a <a href="https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/">join column of an association</a>, this strategy concatenates the name of the referencing attribute, an &#8220;_&#8221; and the name of the primary key attribute of the referenced entity. The logical name of a join column of an element collection consists of the name of the entity that owns the association, an &#8220;_&#8221; and the name of the <a href="https://thorben-janssen.com/jpa-generate-primary-keys/">primary key</a> attribute of the referenced entity. And the logical name of a join table starts with the physical name of the owning table, followed by an &#8220;_&#8221; and the physical name of the referencing table.</li>



<li><strong>legacy-hbm<br></strong>This is Hibernate&#8217;s original naming strategy. It doesn&#8217;t recognize any of JPA&#8217;s annotations. But you can use Hibernate&#8217;s proprietary configuration file and annotations to define a column or entity name.<br>In addition to that, there are a few other differences to the JPA specification:
<ul>
<li>The logical name of a join column is only its attribute name.</li>



<li>For join tables, this strategy concatenates the name of the physical table that owns the association, an &#8220;_&#8221; and the name of the attribute that owns the association.</li>
</ul>
</li>



<li><strong>legacy-jpa</strong><br>The legacy-jpa strategy implements the naming strategy defined by JPA 1.0.<br>The main differences to the jpa strategy are:
<ul>
<li>The logical name of a join table consists of the physical table name of the owning side of the association, an &#8220;_&#8221; and either the physical name of the referencing side of the association or the owning attribute of the association.</li>



<li>To get the logical name of the join column of an <a href="https://thorben-janssen.com/hibernate-tips-query-elementcollection/">element collection</a>, the legacy-jpa strategy uses the physical table name instead of the entity name of the referenced side of the association. That means the logical name of the join column consists of the physical table name of the referenced side of the association, an &#8220;_&#8221; and the name of the referenced primary key column.</li>
</ul>
</li>



<li><strong>component-path<br></strong>This strategy is almost identical to the jpa strategy. The only difference is that it includes the name of the composite in the logical attribute name.</li>
</ul>



<p>You can configure the logical naming strategy by setting the hib<em>ernate.implicit_naming_strategy</em> attribute in your configuration.</p>



<pre class="wp-block-preformatted brush: xml; gutter: true">&lt;persistence&gt;
    &lt;persistence-unit name="naming"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.implicit_naming_strategy"
                      value="jpa" /&gt;
            ...
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>



<h2 class="wp-block-heading">Physical naming strategy</h2>



<p>As mentioned earlier, Hibernate&#8217;s default physical naming strategy uses the logical name without changing it. So, whatever the logic name is, it will also be the name of the database table or column.</p>



<p>If you prefer a different mapping, you can define a custom strategy. I will show you how to do that later in this article. But before that, I want to show you the&nbsp;<em>CamelCaseToUnderscoresNamingStrategy&nbsp;</em>that was introduced in Hibernate 5.5.4. It replicates the mapping used by Spring Boot’s&nbsp;<em>SpringPhysicalNamingStrategy</em>.</p>



<h3 class="wp-block-heading"><em>CamelCaseToUnderscoresNamingStrategy </em>in Hibernate &gt;5.5.4</h3>



<p>Spring&#8217;s <em>SpringPhysicalNamingStrategy</em> has become very popular. It not only gets used by default in Spring Boot applications, but many developers also started to apply it to non-Spring projects. It replaces all dots and camel casing with underscores and generates all tables names in lower case.</p>



<h4 class="wp-block-heading">Activating Hibernate&#8217;s <em>CamelCaseToUnderscoresNamingStrategy</em></h4>



<p>The Hibernate team replicated that mapping strategy in the <em>CamelCaseToUnderscoresNamingStrategy</em>. Since Hibernate 5.5.4.Final, you can activate this strategy by setting the configuration property <em>hibernate.physical_naming_strategy</em> in your persistence.xml file to <em>org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy</em>.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: xml; title: ; notranslate" title="">
&lt;persistence&gt;
    &lt;persistence-unit name=&quot;my-persistence-unit&quot;&gt;
        ...

        &lt;properties&gt;
            ...
			
            &lt;property name=&quot;hibernate.physical_naming_strategy&quot;
                      value=&quot;org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy&quot;/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre></div>


<h4 class="wp-block-heading">Using Hibernate&#8217;s <em>CamelCaseToUnderscoresNamingStrategy</em></h4>



<p>We need an entity class name in camel case to show this strategy in all details. Because of that, I’m using the&nbsp;<em>ChessPlayer</em>&nbsp;entity instead of the&nbsp;<em>Author&nbsp;</em>entity you saw in previous examples.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
public class ChessPlayer {

	@Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;player_seq&quot;)
    @SequenceGenerator(name = &quot;player_seq&quot;, sequenceName = &quot;player_seq&quot;, initialValue = 100)
	private Long id;

    private String firstName;
    
    private String lastName;

    private LocalDate birthDate;

    @OneToMany(mappedBy = &quot;playerWhite&quot;)
    private Set&lt;ChessGame&gt; gamesWhite;

    @OneToMany(mappedBy = &quot;playerBlack&quot;)
    private Set&lt;ChessGame&gt; gamesBlack;

    @Version
    private int version;
	
	...
	
}
</pre></div>


<p>As you can see in the code snippet, I don&#8217;t define any logical names for the entity class and its attributes. By default, Hibernate then uses the Java class&#8217;s name and the names of each of its attributes as their logical names.</p>



<p>Hibernate&#8217;s&nbsp;<em>CamelCaseToUnderscoresNamingStrategy&nbsp;</em>physical naming strategy replaces all dots and camel casing with underscores and changes the logical class name to lower case. Based on this mapping, the <em>ChessGame</em> entity class gets mapped to the <em>chess_game </em>table. And the attributes <em>firstName</em>, <em>lastName</em>, and <em>birthDate</em> get mapped to the columns <em>first_name</em>, <em>last_name</em>, and <em>birth_date</em>.</p>



<p>You can see that when I persist a new <em>ChessGame</em> entity object.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
19:27:25,995 DEBUG SQL:144 - select chessplaye0_.id as id1_1_0_, chessplaye0_.birth_date as birth_da2_1_0_, chessplaye0_.first_name as first_na3_1_0_, chessplaye0_.last_name as last_nam4_1_0_, chessplaye0_.version as version5_1_0_ from chess_player chessplaye0_ where chessplaye0_.id=?
</pre></div>


<h3 class="wp-block-heading">Implementing a custom physical naming strategy</h3>



<p>If none of Hibernate&#8217;s physical naming strategies fulfill your requirements, you can implement your own strategy. Doing that isn&#8217;t complicated. You can either implement the&nbsp;<em>PhysicalNamingStrategy&nbsp;</em>interface or extend Hibernate&#8217;s&nbsp;<em>PhysicalNamingStrategyStandardImpl&nbsp;</em>class.</p>



<p>I extend Hibernate’s&nbsp;<em>PhysicalNamingStrategyStandardImpl</em>&nbsp;in the following example to create a naming strategy that adds the postfix “_TBL” to each table name And in the 2nd example, we will define a naming strategy that converts camel case names into snake case.</p>



<h4 class="wp-block-heading">Table postfix strategy</h4>



<p>The only thing I want to change in this naming strategy is the handing of the table name. Extending Hibernate’s&nbsp;<em>PhysicalNamingStrategyStandardImpl&nbsp;</em>class is the easiest way to achieve that.</p>



<h5 class="wp-block-heading">Implementing a custom strategy</h5>



<p>I overwrite the <em>toPhysicalTableName </em>method, add a static postfix to the name, and convert it into an <em>Identifier</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">public class TablePostfixPhysicalNamingStrategy extends PhysicalNamingStrategyStandardImpl {

    private final static String POSTFIX = "_TBL";
    
    @Override
    public Identifier toPhysicalTableName(final Identifier identifier, final JdbcEnvironment jdbcEnv) {
        if (identifier == null) {
            return null;
        }

        final String newName = identifier.getText() + POSTFIX;
        return Identifier.toIdentifier(newName);
    }

}
</pre>



<p>In the next step, you need to activate the naming strategy. You do that by setting the <em>hibernate.physical_naming_strategy</em> attribute to the fully qualified class name of the strategy.</p>



<pre class="wp-block-preformatted brush: xml; gutter: true">&lt;persistence&gt;
    &lt;persistence-unit name="naming"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.physical_naming_strategy"
                      value="org.thoughtsonjava.naming.config.TablePostfixPhysicalNamingStrategy" /&gt;
            ...
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>



<h5 class="wp-block-heading">Using the table postfix strategy</h5>



<p>Let&#8217;s try this mapping using this basic <em>Author</em> entity. I don&#8217;t specify a logical name for the entity. So, it defaults to the name of the class, which is <em>Author</em>. Without our custom naming strategy, Hibernate would map this entity to the <em>Author</em> table.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Author {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Version
    private int version;

    private String name;

    @ManyToMany(mappedBy = "authors", fetch = FetchType.LAZY)
    private Set&lt;Book&gt; books;

    ...
}</pre>



<p>When I persist this entity, you can see in the <a href="https://thorben-janssen.com/hibernate-logging-guide/">log file</a> that Hibernate mapped it to the <em>AUTHOR_TBL</em> table.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">14:05:56,619 DEBUG [org.hibernate.SQL] - insert into Author_TBL (name, version, id) values (?, ?, ?)</pre>



<h4 class="wp-block-heading">Names in snake case instead of camel case</h4>



<p>In Java, we prefer to use camel case for our class and attribute names. By default, Hibernate uses the logical name as the physical name. So, the entity attribute <a href="https://thorben-janssen.com/hibernate-5-date-and-time/"><em>LocalDate</em> <em>publishingDate</em></a><em> </em>gets mapped to the database column <em>publishingDate</em>.</p>



<p>Some companies use naming conventions that require you to use snake case for your table and column names. That means that your <em>publishingDate</em> attribute needs to be mapped to the <em>publishing_date </em>column.</p>



<p>As explained earlier, you could use the <a href="#explicitNamingStrategy">explicit naming strategy</a> and annotate each attribute with a <em>@Column</em> annotation. But for most persistence layers, that&#8217;s a lot of work, and it&#8217;s easy to forget.</p>



<p>So, let&#8217;s implement a naming strategy that does that for us. </p>



<h5 class="wp-block-heading">Implementing a custom strategy</h5>



<pre class="wp-block-preformatted brush: java; gutter: true">public class SnakeCasePhysicalNamingStrategy extends PhysicalNamingStrategyStandardImpl {

    @Override
    public Identifier toPhysicalCatalogName(Identifier name, JdbcEnvironment context) {
        return super.toPhysicalCatalogName(toSnakeCase(name), context);
    }

    @Override
    public Identifier toPhysicalColumnName(Identifier name, JdbcEnvironment context) {
        return super.toPhysicalColumnName(toSnakeCase(name), context);
    }

    @Override
    public Identifier toPhysicalSchemaName(Identifier name, JdbcEnvironment context) {
        return super.toPhysicalSchemaName(toSnakeCase(name), context);
    }

    @Override
    public Identifier toPhysicalSequenceName(Identifier name, JdbcEnvironment context) {
        return super.toPhysicalSequenceName(toSnakeCase(name), context);
    }

    @Override
    public Identifier toPhysicalTableName(Identifier name, JdbcEnvironment context) {
        return super.toPhysicalTableName(toSnakeCase(name), context);
    }
    
    private Identifier toSnakeCase(Identifier id) {
        if (id == null)
            return id;
            
        String name = id.getText();
        String snakeName = name.replaceAll("([a-z]+)([A-Z]+)", "$1\\_$2").toLowerCase();
        if (!snakeName.equals(name))
            return new Identifier(snakeName, id.isQuoted());
        else
            return id;
    }
}</pre>



<p>The interesting part of this naming strategy is the <em>toSnakeCase</em> method. I call it in all methods that return a physical name to convert the provided name to snake case.</p>



<p>If you&#8217;re familiar with regular expressions, the implementation of the <em>toSnakeCase</em> method is pretty simple. By calling <em>replaceAll(&#8220;([a-z]+)([A-Z]+)&#8221;, &#8220;$1\\_$2&#8221;)</em>, we add an &#8220;_&#8221; in front of each capital letter. After that is done, we only need to change all characters to lower case.</p>



<p>In the next step, we need to set the strategy in the persistence.xml file.</p>



<pre class="wp-block-preformatted brush: xml; gutter: true">&lt;persistence&gt;
    &lt;persistence-unit name="naming"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.physical_naming_strategy"
                      value="org.thoughtsonjava.naming.config.SnakeCasePhysicalNamingStrategy" /&gt;
            ...
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>



<h5 class="wp-block-heading">Using the snake case strategy</h5>



<p>When I now persist this <em>Book</em> entity, Hibernate will use the custom strategy to map the <em>publishingDate </em>attribute to the database column <em>publishing_date</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

    @Id
    @GeneratedValue
    private Long id;

    @Version
    private int version;

    private String title;

    private LocalDate publishingDate;

    @ManyToMany
    private Set&lt;Author&gt; authors;

    @ManyToOne
    private Publisher publisher;

    ...
}</pre>



<p>As you can see in the log file, the naming strategy worked as expected and changed the name of the <em>publishingDate </em>column to <em>publishing_date</em>.</p>



<pre class="wp-block-preformatted brush: sql; gutter: true">14:28:59,337 DEBUG [org.hibernate.SQL] - insert into books (publisher_id, publishing_date, title, version, id) values (?, ?, ?, ?, ?)</pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Hibernate&#8217;s naming strategy provides you with lots of flexibility. It consists of 2 parts, the mapping of the logical and the physical name.</p>



<p>You can explicitly define the logical name using the <em>@Table</em> and <em>@Column </em>annotation. If you don&#8217;t do that, Hibernate uses one of its implicit naming strategies. The default one is compliant with JPA 2.0.</p>



<p>After the logical name got determined, Hibernate applies a physical naming strategy. By default, it returns the logical name. Since version 5.5.4, Hibernate also offers the CamelCaseToUnderscoresNamingStrategy. It replaces all dots and camel casing with underscores and generates all tables names in lower case. And you can also implement your own physical naming strategy. Most teams use this to apply a naming convention to all logical entity and attribute names. As you have seen in the examples, this provides an easy way to fulfill your internal naming conventions.</p>
</div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.4.1/dist/js/bootstrap.min.js"></script></body></html>