<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>How to use CockroachDB with Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>How to use CockroachDB with Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p><strong>Disclaimer:</strong> This post is sponsored by <a href="https://www.cockroachlabs.com/" target="_blank" rel="noreferrer noopener sponsored nofollow">Cockroach Labs</a>.</p>



<p>CockroachDB is an open-source relational database designed to be highly scalable and reliable in distributed environments. It&#8217;s available on <a href="https://www.cockroachlabs.com/compare/" target="_blank" rel="noreferrer noopener sponsored nofollow">AWS and Google Cloud or as an on-premise installation</a>. This makes it an interesting candidate for microservice-based applications.</p>



<p>If you want to give it a try or if you&#8217;re already using it, I have great news for you. Since <a href="https://in.relation.to/2020/07/27/hibernate-orm-5419-final-release/" rel="nofollow">version 5.4.19</a>, Hibernate ORM includes a CockroachDB dialect. It makes the database very easy to use and enables the CockroachDB team to support database-specific features with Hibernate in the future. In older releases, you had to rely on CockroachDB&#8217;s PostgreSQL compatibility and Hibernate&#8217;s PostgreSQL dialect. That worked reasonably well. But a database-specific dialect seems to be the better solution.</p>



<p>Let&#8217;s take a look at how to connect Hibernate with your CockroachDB and some database-specific mapping and query recommendations.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Connecting_Hibernate_to_a_CockroachDB_database"><span class="toc_number toc_depth_1">1</span> Connecting Hibernate to a CockroachDB database</a></li><li><a href="#3_Things_You_Should_Know"><span class="toc_number toc_depth_1">2</span> 3 Things You Should Know</a><ul><li><a href="#Primary_Key_Generation"><span class="toc_number toc_depth_2">2.1</span> Primary Key Generation</a></li><li><a href="#Mapping_Views"><span class="toc_number toc_depth_2">2.2</span> Mapping Views</a></li><li><a href="#Using_CockroachDB-specific_Query_Features"><span class="toc_number toc_depth_2">2.3</span> Using CockroachDB-specific Query Features</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="Connecting_Hibernate_to_a_CockroachDB_database">Connecting Hibernate to a CockroachDB database</span></h2>



<p>After you installed your database locally or set up an instance at one of the supported cloud providers, you need to configure Hibernate to connect to it. </p>



<p>As explained earlier, CockroachDB is compatible with PostgreSQL. Due to that, you can use PostgreSQL&#8217;s JDBC driver and connection information when defining your datasource. The only CockroachDB-specific part of your configuration is the dialect. You should set it to the CockroachDB dialect that fits the version of your database.</p>



<p>In the following example, I use the user <em>root </em>and an empty password to connect to a CockroachDB single-node cluster that runs in a Docker container on my local machine. In a production environment, you would use a similar configuration to connect to a multi-node cluster with encrypted network communication and better user authentication.</p>



<pre class="wp-block-preformatted brush: xml; gutter: true">&lt;persistence&gt;
    &lt;persistence-unit name=&quot;my-persistence-unit&quot;&gt;
        &lt;properties&gt;
            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.CockroachDB201Dialect&quot; /&gt;

            &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;org.postgresql.Driver&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:26257/defaultdb?sslmode=disable&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot; /&gt;
            &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;&quot; /&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>



<p>This is the only CockroachDB-specific thing you need to do to build a basic Hibernate-based application.</p>



<h2><span id="3_Things_You_Should_Know">3 Things You Should Know</span></h2>



<p>Hibernate&#8217;s CockroachDB dialect handles all the database-specific details. You can now use your standard entity mappings and queries to build your persistence layer. But as for all databases, you should know a few things to create an efficient persistence layer.</p>



<h3><span id="Primary_Key_Generation">Primary Key Generation</span></h3>



<p>When your application adds many records to the database, Hibernate&#8217;s primary key generation strategy often becomes a performance-critical mapping detail. Using JPA and Hibernate, you can <a href="https://thorben-janssen.com/jpa-generate-primary-keys/">define the strategy</a> by annotating your primary key attribute with <em>@GeneratedValue</em>. The provided <em>GenerationType</em> enum specifies the strategy, and you can choose between an auto-incremented column and a sequence.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;
	
    ...
}</pre>



<p>If you&#8217;re a regular reader of this blog, you know that I always recommend using <em>GenerationType.SEQUENCE</em> with Hibernate. It&#8217;s the most efficient because Hibernate can split the generation of a new primary key value from the execution of the insert statement. Hibernate also provides proprietary optimizations to reduce the number of database interactions.</p>



<p>Unfortunately, the CockroachDB documentation discourages the usage of sequences. Their standard indexing of sequential values isn&#8217;t as efficient as it is for UUIDs. But their generation of UUIDs is based on a default value, similar to an autoincremented column, and I couldn&#8217;t use it with Hibernate. Your current best option is to use a database sequence and a <a href="https://www.cockroachlabs.com/docs/v20.2/indexes#hash-sharded-indexes" target="_blank" rel="noreferrer noopener sponsored nofollow">hash-sharded index</a> on the primary key column. This index provides better performance than the standard one.</p>



<h3><span id="Mapping_Views">Mapping Views</span></h3>



<p>Database views are a popular feature to reduce query complexity and restrict access to parts of your data. You can map them in the same way as you map a database table. As long as your Java class is not final, has the same name as your database view, and each attribute maps a column with the same name, you only need to annotate the class with <em>@Entity</em> and the primary key attribute with <em>@Id</em>. Everything else gets handled by Hibernate automatically.</p>



<p>But there is one crucial difference between a database view and a table. You often can&#8217;t change the data in a view. If that&#8217;s the case for your view, you should tell Hibernate about it. You should annotate your entity class with <em>@Immutable</em>, <a href="https://thorben-janssen.com/access-strategies-in-jpa-and-hibernate/">use field-based access</a>, and don&#8217;t provide any setter methods.</p>



<p>Here you can see a simple example that maps the database view <em>BookAuthorView</em>.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Entity
@Immutable
public class AuthorBookView {
    
    @Id
    private Long bookId;

    private String authorName;

    private String title;

    public Long getBookId() {
        return bookId;
    }

    public String getAuthorName() {
        return authorName;
    }

    public String getTitle() {
        return title;
    }
}</pre>



<p>Using this mapping, you can use the <em>AuthorBookView </em>entity in your queries in the same way as any other entity. But Hibernate will ignore it in its dirty checks. Due to that, it will not try to insert, update, or remove any records in that view.</p>



<h3><span id="Using_CockroachDB-specific_Query_Features">Using CockroachDB-specific Query Features</span></h3>



<p>Even if you use a database-specific dialect, JPQL and the Criteria API don&#8217;t support all query features offered by your database. To use any of CockroachDB&#8217;s more advanced features, like window functions, you need to use a native SQL query.</p>



<p>You can create a native SQL query by calling the <em>createNativeQuery </em>method on your <em>EntityManager</em> and providing the SQL statement as a <em>String</em>. </p>



<pre class="wp-block-preformatted brush: sql; gutter: true">em.createNativeQuery(&quot;SELECT DISTINCT name, &quot;
						+ &quot;COUNT(*)     OVER b AS \&quot;number of books\&quot;, &quot;
						+ &quot;(AVG(pages) OVER b) AS \&quot;average pages per book\&quot; &quot;
					+ &quot;FROM author &quot;
						+ &quot;JOIN book_author ON author.id = book_author.authors_id &quot;
						+ &quot;JOIN book ON book.id = book_author.book_id &quot;
					+ &quot;WINDOW b AS (PARTITION BY name)&quot;).getResultList();</pre>



<p>Hibernate sends the provided SQL statement to the database. So, it&#8217;s your responsibility to ensure that all RDBMS supported by your application can handle the provided statement. This makes it harder to support multiple RDBMS. But it also enables you to use all proprietary features supported by your database.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Hibernate&#8217;s dialect and PostgreSQL&#8217;s JDBC driver enable you to use CockroachDB in the same way as any other database with Hibernate. You only need to configure a database-specific dialect and the connection URL to your database.</p>



<p>In addition to this, you should pay special attention to your primary key mappings. Hibernate prefers sequence-based primary key values, which require a special index in your CockroachDB schema.</p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>