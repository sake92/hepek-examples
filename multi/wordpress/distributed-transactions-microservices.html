<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Distributed Transactions – Don’t use them for Microservices</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Distributed Transactions – Don’t use them for Microservices</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Since I started talking about microservices and the challenges that you have to solve whenever you want to exchange data between your services, I hear 3 things:</p>



<ol><li>You only need to model the scope of your services “the right way” to avoid these problems.</li><li>We use multiple local transactions, and everything works fine. It&#8217;s really not that big of a deal.</li><li>We have always used distributed transactions to ensure data consistency. We will keep doing that for our microservice architecture.</li></ol>



<p>Let&#8217;s quickly address the first 2 answers before we get to the main part of this article.</p>



<!--more-->



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#Designing_services_the_right_way"><span class="toc_number toc_depth_1">1</span> Designing services the right way</a></li><li><a href="#Using_multiple_local_transactions"><span class="toc_number toc_depth_1">2</span> Using multiple local transactions</a></li><li><a href="#Distributed_transactions_and_their_problems_in_a_microservice_application"><span class="toc_number toc_depth_1">3</span> Distributed transactions and their problems in a microservice application</a><ul><li><a href="#2-phase_commit_protocol"><span class="toc_number toc_depth_2">3.1</span> 2-phase commit protocol</a></li><li><a href="#The_problem_of_a_2-phase_commit"><span class="toc_number toc_depth_2">3.2</span> The problem of a 2-phase commit</a></li></ul></li></ul></div>
<h2><span id="Designing_services_the_right_way">Designing services the right way</span></h2>



<p>It&#8217;s a popular myth that you can solve all problems by designing the scope of your services the right way. That might be the case for highly scalable &#8220;hello&#8221; world applications that you see in demos. But it doesn&#8217;t work that way in the real world. </p>



<p>Don&#8217;t get me wrong; designing the scope of your services is important, and it makes the implementation of your application easier. But you will not be able to avoid communication between your services completely. You always have some services that offer their functionality based on other services.</p>



<p>An example of that is an OrderInfo service in an online bookstore. It shows the customer the current status of their order based on the information managed by the Order service, the Inventory service, and the Book service.</p>



<p>Another example is an Inventory service, which needs to reserve a book for a specific order and prepare it for delivery after the Order and the Payment service processed the order.</p>



<p>In these cases, you either:</p>



<ul><li>Implement some form of data exchange between these services or </li><li>Move all the logic to the frontend, which in the end is the same approach as option 1, or </li><li>Merge all the services into 1, which gets you a monolithic application.</li></ul>



<p>As you can see, there are several situations in which you need to design and implement some form of communication and exchange data between your services. And that&#8217;s OK if you do it intentionally. There are several patterns and tools for that. I explain the most important and popular ones in my upcoming course <a href="https://thorben-janssen.com/data-and-communication-patterns-for-microservices/">Data and Communication Patterns for Microservices</a>. It launches in just a few days. I recommend joining the waitlist now so that you don&#8217;t miss it.</p>



<h2><span id="Using_multiple_local_transactions">Using multiple local transactions</span></h2>



<p>If teams accepted that they need to exchange data between their services, quite a few decide to use multiple, independent, local transactions. This is a risky decision because sooner or later, it will cause data inconsistencies.</p>



<p>By using multiple local transactions, you create a situation that&#8217;s called a <a href="https://thorben-janssen.com/dual-writes/">dual write</a>. I explained it in great detail in a previous article. To summarize that article, you can&#8217;t handle the situation in which you try to commit 2 independent transactions, and the 2nd commit fails. You might try to implement workarounds that try to revert the first transaction. But you can&#8217;t guarantee that they will always work.</p>



<h2><span id="Distributed_transactions_and_their_problems_in_a_microservice_application">Distributed transactions and their problems in a microservice application</span></h2>



<p>In a monolithic application or older distributed applications, we often used transactions that span over multiple external systems. Typical examples are transactions that include one or more databases or a database and a message broker. These transactions are called global or distributed transactions. They enable you to apply the ACID principle to multiple systems.</p>



<p>Unfortunately, they are not a good fit for a microservice architecture. They use a pattern called 2-phase commit. This pattern describes a complex process that requires multiple steps and locks.</p>



<h3><span id="2-phase_commit_protocol">2-phase commit protocol</span></h3>



<p>As you might have guessed from the name, the main difference between a local and distributed transaction that uses the two-phase commit pattern is the commit operation. As soon as more than one system is involved, you can’t just send a commit message to each of them. That would create the same problems as we discussed for <a href="https://thorben-janssen.com/dual-writes/">dual writes</a>.</p>



<p>The two-phase commit avoids these problems by splitting the commit into 2 steps: </p>



<ol><li>The transaction coordinator first sends a prepare command to each involved system. <br>Each system then checks if they could commit the transaction. </li><li>If that’s the case, they respond with “prepared” and the transaction coordinator sends a commit command to all systems. The transaction was successful, and all changes get committed.<br> If any of the systems doesn’t answer the prepare command or responds with “failed”, the transaction coordinator sends an abort command to all systems. This rolls back all the changes performed within the transaction.</li></ol>



<figure class="wp-block-image size-large"><img width="1024" height="576" src="https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-1024x576.png" alt="" class="wp-image-24192" srcset="https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-1024x576.png 1024w, https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-300x169.png 300w, https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-768x432.png 768w, https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-1536x864.png 1536w, https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit-400x225.png 400w, https://thorben-janssen.com/wp-content/uploads/2020/02/Distributed-Transactions-2phase-commit.png 1920w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>As you can see, a two-phase commit is more complicated than the simple commit of a local transaction. But it gets even worse when you take a look at the systems that need to prepare and commit the transaction.</p>



<h3><span id="The_problem_of_a_2-phase_commit">The problem of a 2-phase commit</span></h3>



<p>After a system confirmed the prepare command, it needs to make sure that it will be able to commit the transaction when it receives the commit command. That means nothing is allowed to change until that system gets the commit or abort command. </p>



<p>The only way to ensure that is to lock all the information that you changed in the transaction. As long as this lock is active, no other transaction can use this information. These locks can become a bottleneck that slows down your system and should obviously be avoided.</p>



<p>This problem also existed in a distributed, monolithic application. But the small scope of a microservice and the huge number of services that are often deployed make it worse. </p>



<p>A 2-phase commit between a transaction coordinator and 2 external systems is already bad enough. But the complexity and the performance impact of the required locks increase with each additional external system that takes part in the transaction.</p>



<p>Due to that, a distributed transaction is no longer an easy to use approach to ensure data consistency that, in the worst case, might slow down your application a little bit. In a microservice architecture, a distributed transaction is an outdated approach that causes severe scalability issues. Modern patterns that rely on asynchronous data replication or model distributed write operations as orchestrated or choreographed SAGAs avoid these problems. I explain all of them in great detail in my course <a href="https://thorben-janssen.com/data-and-communication-patterns-for-microservices/">Data and Communication Patterns for Microservices</a>. </p></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>