<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Projections with JPA and Hibernate</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Projections with JPA and Hibernate</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Choosing the right projection when selecting data with JPA and Hibernate is incredibly important. When I&#8217;m working with a coaching client to improve the performance of their application, we always work on slow queries. At least 80% of them can be tremendously improved by either adjusting the projection or by <a href="https://thorben-janssen.com/entity-mappings-introduction-jpa-fetchtypes/">using the correct FetchType</a>. </p>



<p>Unfortunately, changing the projection of an existing query always requires a lot of refactoring in your business code. So, better make sure to pick a good projection in the beginning. That&#8217;s relatively simple if you follow a few basic rules that I will explain in this article.</p>



<p>But before we do that, let&#8217;s quickly explain what a projection is.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#What_is_a_projection"><span class="toc_number toc_depth_1">1</span> What is a projection?</a></li><li><a href="#What_projections_do_JPA_and_Hibernate_support"><span class="toc_number toc_depth_1">2</span> What projections do JPA and Hibernate support?</a><ul><li><a href="#Entity_projections"><span class="toc_number toc_depth_2">2.1</span> Entity projections</a></li><li><a href="#Scalar_value_projections"><span class="toc_number toc_depth_2">2.2</span> Scalar value projections</a><ul><li><a href="#Database_functions_in_scalar_value_projections"><span class="toc_number toc_depth_3">2.2.1</span> Database functions in scalar value projections</a></li></ul></li><li><a href="#DTO_projections"><span class="toc_number toc_depth_2">2.3</span> DTO projections</a><ul><li><a href="#Database_functions_in_DTO_projections"><span class="toc_number toc_depth_3">2.3.1</span> Database functions in DTO projections</a></li></ul></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="What_is_a_projection">What is a projection?</span></h2>



<p>The projection describes which columns you select from your database and in which form Hibernate provides them to you. Or in other words, if you&#8217;re writing a <a href="https://thorben-janssen.com/jpql/">JPQL query</a>, it&#8217;s everything between the SELECT and the FROM keywords.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">em.createQuery(&quot;SELECT b.title, b.publisher, b.author.name FROM Book b&quot;);</pre>



<h2><span id="What_projections_do_JPA_and_Hibernate_support">What projections do JPA and Hibernate support?</span></h2>



<p>JPA and Hibernate support 3 groups of projections:</p>



<ol><li>Scalar values</li><li>Entities</li><li>DTOs</li></ol>



<p>SQL only supports scalar projections, like table columns or the return value of a database function. So, how can JPA and Hibernate support more projections?</p>



<p>Hibernate first checks which information it needs to retrieve from the database and generates an SQL statement with a scalar value projection for it. It then executes the query and returns the result if you used a scalar value projection in your code. If you requested a DTO or entity projection, Hibernate applies an additional transformation step. It iterates through the result set and instantiates an entity or a DTO object for each record.</p>



<p>Let&#8217;s take a closer look at all 3 projections and discuss when you should use which of them.</p>



<h3><span id="Entity_projections">Entity projections</span></h3>



<p>For most teams, entities are the most common projection. They are very easy to use with JPA and Hibernate. </p>



<p>You can either use the <em>find </em>method on your <em>EntityManager</em> or write a simple <a href="https://thorben-janssen.com/jpql/">JPQL</a> or Criteria query that selects one or more entities. Spring Data JPA can even <a href="https://thorben-janssen.com/ultimate-guide-derived-queries-with-spring-data-jpa/">derive a query</a> that returns an entity from the name of your repository method.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Book&gt; q = em.createQuery(&quot;SELECT b FROM Book b&quot;, Book.class);
List&lt;Book&gt; books = q.getResultList();
</pre>



<p>All entities that you load from the database or retrieve from one of Hibernate&#8217;s caches are in the lifecycle state managed. That means that your persistence provider, e.g., Hibernate, will automatically update or remove the corresponding database record if you change the value of an entity attribute or decide to remove the entity.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">b.setTitle(&quot;Hibernate Tips - More than 70 solutions to common Hibernate problems&quot;);</pre>



<p>Entities are the only projection that has a managed lifecycle state. Whenever you want to implement a write operation, you should fetch entities from the database. They make the implementation of write operations much easier and often even provide performance optimizations.</p>



<p>But if you implement a read-only use case, you should prefer a different projection. Managing the lifecycle state, ensuring that there is only 1 entity object for each mapped database record within a session, and all the other features provided by Hibernate create an overhead. This overhead makes the entity projection slower than a scalar value or DTO projection.</p>



<h3><span id="Scalar_value_projections">Scalar value projections</span></h3>



<p>Scalar value projections avoid the management overhead of entity projections, but they are not very comfortable to use. Hibernate doesn&#8217;t transform the result of the query. You, therefore, get an <em>Object </em>or an <em>Object[] </em>as the result of your query.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">Query q = em.createQuery(&quot;SELECT b.title, b.publisher, b.author.name FROM Book b&quot;);
List&lt;Object[]&gt; books = (Object[]) q.getResultList();</pre>



<p>In the next step, you then need to iterate through each record in your result set and cast each <em>Object</em> to its specific type before you can use it. That makes your code error-prone and hard to read.</p>



<p>Instead of an <em>Object[]</em>, you can also retrieve a scalar projection as a <em>Tuple</em> interface. The interface is a little easier to use than the Object[]. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Tuple&gt; q = em.createQuery(&quot;SELECT b.title as title, b.publisher as publisher, b.author.name as author FROM Book b&quot;, Tuple.class);
List&lt;Tuple&gt; books = q.getResultList();

for (Tuple b : books) {
	log.info(b.get(&quot;title&quot;));
}</pre>



<p>But don&#8217;t expect too much. It only provides a few additional methods to retrieve an element, e.g., by its alias. But the returned values are still of type <em>Object</em>, and your code is still as error-prone as it is if you use an Object[].</p>



<h4><span id="Database_functions_in_scalar_value_projections">Database functions in scalar value projections</span></h4>



<p>Scalar value projections are not limited to singular entity attributes. You can also include the return values of one or more database functions.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;Tuple&gt; q = em.createQuery(&quot;SELECT AVG(b.sales) as avg_sales, SUM(b.sales) as total_sales, COUNT(b) as books, b.author.name as author FROM Book b GROUP BY b.author.name&quot;, Tuple.class);
List&lt;Tuple&gt; authors = q.getResultList();

for (Tuple a : authors) {
	log.info(&quot;author:&quot; + a.get(&quot;author&quot;)
			+ &quot;, books:&quot; + a.get(&quot;books&quot;)
			+ &quot;, AVG sales:&quot; + a.get(&quot;avg_sales&quot;)
			+ &quot;, total sales:&quot; + a.get(&quot;total_sales&quot;));
}</pre>



<p>This is a huge advantage compared to an entity projection. If you used an entity projection in the previous example, you would need to select all <em>Book</em> entities with their associated <em>Author</em> entity. In the next step, you would then need to count the number of books each author has written, and calculate the total and average sales values. </p>



<p>As you can see in the code snippet, using a database function is easier, and it also provides better performance.</p>



<h3><span id="DTO_projections">DTO projections</span></h3>



<p>DTO projections are the best kind of projection for read-only operations. Hibernate instantiates the DTO objects as a post-processing step after it retrieved the query result from the database. It then iterates through the result set and executes the described constructor call for each record.</p>



<p>Here you can see a simple example of a JPQL query that returns the query result as a <em>List</em> of <em>BookDTO </em>objects. By using the keyword <em>new</em> and providing the fully qualified class name of your DTO class and an array of references to entity attributes, you can define a constructor call. Hibernate will then use reflection to call this constructor.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">TypedQuery&lt;BookDTO&gt; q = em.createQuery(&quot;SELECT new org.thoughtsonjava.projection.dto.BookDTO(b.title, b.author.name, b.publisher) FROM Book b&quot;, BookDTO.class);
List&lt;BookDTO&gt; books = q.getResultList();</pre>



<p>In contrast to the entity projection, the overhead of a DTO projection is minimal. The objects are not part of the current persistence context and don&#8217;t follow any managed lifecycle. Due to that, Hibernate will not generate any SQL UPDATE statements if you change the value of a DTO attribute. But it also doesn&#8217;t have to spend any management effort, which provides <a href="https://thorben-janssen.com/entities-dtos-use-projection/">significant performance benefits</a>.</p>



<h4><span id="Database_functions_in_DTO_projections">Database functions in DTO projections</span></h4>



<p>Similar to a scalar value projection, you can also use database functions in a DTO projection. As explained earlier, the instantiation of the DTO object is a post-processing step after Hibernate retrieved the query result. At that phase, it doesn&#8217;t make any difference if a value was stored in a database column or if it was calculated by a database function. Hibernate simply gets it from the result set and provides it as a constructor parameter.</p>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>JPA and Hibernate support 3 groups of projections:</p>



<ol><li>Entities are the easiest and most common projection. They are a great fit if you need to change data, but they are not the most efficient ones for read-only use cases.</li><li>Scalar projections are returned as <em>Object[]</em>s or instances of the <em>Tuple </em>interface. Both versions don&#8217;t provide any type-information and are hard to use. Even though they are very efficient for read-only operations, you should avoid them in your application. </li><li>DTO projections provide similar performance as scalar value projections but are much easier to use. That makes them the best projection for read-only operations.</li></ol></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>