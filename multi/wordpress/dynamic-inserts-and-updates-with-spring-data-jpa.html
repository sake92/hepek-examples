<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Dynamic Inserts and Updates with Spring Data JPA</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/css/bootstrap.min.css" /><style>
    nav#tocScrollspy {
      display: none;
    }

    @media (min-width: 991px) {
      .affix {
          position: fixed;
          width: 10%;
      }

      nav#tocScrollspy {
        display: block;
      }
    }
    </style></head><body><div class="container-fluid"><div><div class="page-header text-center"><h1>Dynamic Inserts and Updates with Spring Data JPA</h1></div><div class="row"><div class="col-lg-2 col-md-0 invisible"></div><div class="col-lg-8 col-md-12">
<p>When you persist a new entity or update an existing one with Spring Data JPA, you might have recognized that you&#8217;re always executing the same SQL statement that sets all columns mapped by the entity. That&#8217;s even the case if you only update one of its attributes. </p>



<p>That is a performance optimization provided by Hibernate, the JPA implementation that Spring Data JPA uses by default. Hibernate tries to avoid checking which attributes of an entity have changed and generating a specific SQL statement for them. It instead generates 1 SQL UPDATE and 1 SQL INSERT statement for each entity class at startup and reuses it for every insert or update operation.</p>



<p>Reusing the same statement over and over again improves Hibernate&#8217;s work. But it also creates some side effects. These statements create an overhead if you only change 1 attribute of a huge entity class. They also cause problems if you need to audit all changes performed on a database table. In these cases, it might be better to let Hibernate generate a new SQL INSERT or UPDATE statement for each operation.</p>



<h2 class="wp-block-heading">Standard behavior</h2>



<p>But before I show you how to do that, let&#8217;s take a quick look at the default behavior. Here, you can see a simple <em>ChessPlayer</em> entity that stores each player&#8217;s <em>firstName</em>, <em>lastName</em>, and <em>birthDate</em>. The <em>id</em> attribute maps the primary key, and its values get generated by a database sequence.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
public class ChessPlayer {

	@Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;player_seq&quot;)
    @SequenceGenerator(name = &quot;player_seq&quot;, sequenceName = &quot;player_sequence&quot;)
	private Long id;

    private String firstName;
    
    private String lastName;

    private LocalDate birthDate;

	...
}
</pre></div>


<p>I prepared a standard repository that only extends Spring Data JPA&#8217;s <em>JpaRepository </em>and doesn&#8217;t add any custom queries or other functionality.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
public interface ChessPlayerRepository extends JpaRepository&lt;ChessPlayer, Long&gt; { }
</pre></div>


<p>And I prepared a test case that persists a new <em>ChessPlayer</em> without setting his <em>birthDate</em> attribute. In the next step, I fix a typo in the <em>firstName</em>. This will trigger an additional SQL UPDATE statement.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
ChessPlayer p = new ChessPlayer();
p.setFirstName(&quot;Torben&quot;);
p.setLastName(&quot;Janssen&quot;);
chessPlayerRepository.save(p);

p.setFirstName(&quot;Thorben&quot;);
</pre></div>


<p>As you can see in the log output, Hibernate executed an SQL INSERT and an UPDATE statement that set all columns of the <em>Chess_Player </em>table. This includes the <em>birth_date</em> column, which gets set to null.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
11:33:15.505 DEBUG 19836 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:33:15.514 DEBUG 19836 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:33:15.547 DEBUG 19836 --- &#x5B;           main] org.hibernate.SQL                        : insert into chess_player (birth_date, first_name, last_name, id) values (?, ?, ?, ?)
11:33:15.557 DEBUG 19836 --- &#x5B;           main] org.hibernate.SQL                        : update chess_player set birth_date=?, first_name=?, last_name=? where id=?
</pre></div>


<h2 class="wp-block-heading">Hibernate&#8217;s @DynamicInsert</h2>



<p>Spring Data JPA acts as a layer on top of Hibernate. Due to that, you can use all of Hibernate’s proprietary mapping annotations on your entity classes. </p>



<p>If you want to dynamically generate the SQL INSERT statement when persisting a new entity object, you need to annotate the entity class with Hibernate’s proprietary&nbsp;<em>@DynamicInsert</em>&nbsp;annotation.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
@DynamicInsert
public class ChessPlayer {

	@Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;player_seq&quot;)
    @SequenceGenerator(name = &quot;player_seq&quot;, sequenceName = &quot;player_sequence&quot;)
	private Long id;

    private String firstName;
    
    private String lastName;

    private LocalDate birthDate;
	
	...
}
</pre></div>


<p>When you then execute the same test case as before, you will see in the log output that Hibernate generated the SQL INSERT statement dynamically using only the attributes set on the new entity object.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
ChessPlayer p = new ChessPlayer();
p.setFirstName(&quot;Torben&quot;);
p.setLastName(&quot;Janssen&quot;);
chessPlayerRepository.save(p);

p.setFirstName(&quot;Thorben&quot;);
</pre></div>


<p>Hibernate only sets the <em>id</em>, <em>first_name</em>, and <em>last_name</em> columns in the SQL INSERT statement, but not the <em>birth_date </em>column. Hibernate excluded that column because I didn’t set it in the test case before calling the save method on Spring Data JPA’s repository.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
11:37:20.374 DEBUG 7448 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:37:20.386 DEBUG 7448 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:37:20.427 DEBUG 7448 --- &#x5B;           main] org.hibernate.SQL                        : insert into chess_player (first_name, last_name, id) values (?, ?, ?)
11:37:20.435 DEBUG 7448 --- &#x5B;           main] org.hibernate.SQL                        : update chess_player set birth_date=?, first_name=?, last_name=? where id=?
</pre></div>


<p>But the SQL UPDATE statement still updates all columns mapped by the <em>ChessPlayer </em>entity class. If you want to change that, you also need to annotate the entity class with <em>@DynamicUpdate</em>.</p>



<h2 class="wp-block-heading">Hibernate&#8217;s @DynamicUpdate</h2>



<p>Like the <em>@DynamicInsert</em> annotation described in the previous section, the <em>@DynamicUpdate</em> annotation tells Hibernate to generate a specific SQL UPDATE statement for each update operation. When doing that, Hibernate detects which attributes have changed and only includes these in the SQL statements.</p>



<p>In the following example, I annotated the <em>ChessPlayer </em>entity with Hibernate&#8217;s <em>@DynamicInsert</em> and <em>@DynamicUpdate </em>annotation.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
@Entity
@DynamicInsert
@DynamicUpdate
public class ChessPlayer {

	@Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;player_seq&quot;)
    @SequenceGenerator(name = &quot;player_seq&quot;, sequenceName = &quot;player_sequence&quot;)
	private Long id;

    private String firstName;
    
    private String lastName;

    private LocalDate birthDate;
	
	...
}
</pre></div>


<p>Let&#8217;s execute the same test case as in the previous examples.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: java; title: ; notranslate" title="">
ChessPlayer p = new ChessPlayer();
p.setFirstName(&quot;Torben&quot;);
p.setLastName(&quot;Janssen&quot;);
chessPlayerRepository.save(p);

p.setFirstName(&quot;Thorben&quot;);
</pre></div>


<p>As you can see in the log output, Hibernate now generated specific SQL INSERT and UPDATE statements. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: sql; title: ; notranslate" title="">
11:39:45.177 DEBUG 13832 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:39:45.185 DEBUG 13832 --- &#x5B;           main] org.hibernate.SQL                        : select nextval ('player_sequence')
11:39:45.214 DEBUG 13832 --- &#x5B;           main] org.hibernate.SQL                        : insert into chess_player (first_name, last_name, id) values (?, ?, ?)
11:39:45.224 DEBUG 13832 --- &#x5B;           main] org.hibernate.SQL                        : update chess_player set first_name=? where id=?
</pre></div>


<p>We already discussed the INSERT statement in the previous section, so let&#8217;s focus on the update operation.</p>



<p>In the test case, I only changed the value of the <em>firstName </em>attribute. Hibernate recognized that when it performed a dirty check on that entity object. Based on that, Hibernate then generated an SQL UPDATE statement that only changes the value in the <em>first_name</em> column.</p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Spring Data JPA acts as a layer on top of a JPA implementation. In most cases, that’s Hibernate. When you persist or update an entity object, Spring Data JPA delegates that operation to the JPA implementation. Due to that, the handling of all write operations and the generation of SQL statements depends on your JPA implementation and its capabilities.</p>



<p>By default, Hibernate doesn&#8217;t generate a specific SQL INSERT or UPDATE statement for each entity object. Instead, it generates 1 INSERT and 1 UPDATE statement for each entity class at application startup and reuses them for all insert or update operations. That reduces the overhead of these operations but also changes too many columns in the database.</p>



<p>If that&#8217;s a problem, you can annotate your entity class with @DynamicInsert and @DynamicUpdate. These proprietary annotations tell Hibernate to dynamically generate the SQL INSERT or UPDATE statement for each entity object. When doing that, please keep in mind that you don&#8217;t get this for free and can&#8217;t activate or deactivate it for specific use cases. To generate a specific UPDATE or INSERT statement, Hibernate needs to detect which attributes have changed and generate a new SQL statement based on this information. That slows down all insert or update operations for objects of this entity class.</p>
</div><div class="col-lg-2 col-md-0 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.bundle.min.js"></script></body></html>