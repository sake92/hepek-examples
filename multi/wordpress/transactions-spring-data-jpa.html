<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><title>Managing Transactions with Spring and Spring Data JPA</title><link rel="stylesheet" href="https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css" /></head><body><div class="container-fluid"><div class="hidden-print"></div><div><div class="page-header text-center"><h1>Managing Transactions with Spring and Spring Data JPA</h1></div><div class="row"><div class="col-lg-2 col-md-2 invisible"></div><div class="col-lg-8 col-md-8"><p>Spring Boot and Spring Data JPA make the handling of transactions extremely simple. They enable you to declare your preferred transaction handling and provide seamless integration with Hibernate and JPA.</p>



<p>The only thing you need to do is to annotate one of your methods with @Transactional. But what does that actually do? Which method(s) should you annotate with @Transactional? And why can you set different propagation levels?</p>



<p>I will answer all of these questions in this article. To make that a little bit easier to understand, I will focus on local transactions. These are transactions between your application and 1 external system, e.g., your database. From a Spring application point of view, the same concepts also apply to distributed transactions. So, if you&#8217;re using distributed transactions, I recommend that you keep reading and research the required configuration parameters for distributed transactions afterward. </p>



<p>OK, before we can talk about Spring&#8217;s transaction support, we need to take a step back and explain database transactions in general and take a quick look at JDBC&#8217;s transaction management. This is necessary because Spring&#8217;s transaction management is based on the transaction management provided by your database and the JDBC specification.</p>



<div id="toc_container" class="no_bullets"><p class="toc_title">Contents</p><ul class="toc_list"><li><a href="#What_is_a_transaction"><span class="toc_number toc_depth_1">1</span> What is a transaction?</a><ul><li><a href="#ACID_transactions"><span class="toc_number toc_depth_2">1.1</span> ACID transactions</a></li><li><a href="#Using_transactions_with_JDBC"><span class="toc_number toc_depth_2">1.2</span> Using transactions with JDBC</a></li></ul></li><li><a href="#Managing_Transactions_with_Spring"><span class="toc_number toc_depth_1">2</span> Managing Transactions with Spring</a><ul><li><a href="#Defining_Transaction_Propagation"><span class="toc_number toc_depth_2">2.1</span> Defining Transaction Propagation</a></li><li><a href="#Using_Read-Only_Transactions"><span class="toc_number toc_depth_2">2.2</span> Using Read-Only Transactions</a></li><li><a href="#Handling_Exceptions"><span class="toc_number toc_depth_2">2.3</span> Handling Exceptions</a></li></ul></li><li><a href="#Conclusion"><span class="toc_number toc_depth_1">3</span> Conclusion</a></li></ul></div>
<h2><span id="What_is_a_transaction">What is a transaction?</span></h2>



<p>Transactions manage the changes that you perform in one or more systems. These can be databases, message brokers, or any other kind of software system. The main goal of a transaction is to provide ACID characteristics to ensure the consistency and validity of your data. </p>



<h3><span id="ACID_transactions">ACID transactions</span></h3>



<p>ACID is an acronym that stands for atomicity, consistency, isolation, and durability:</p>



<ul><li><strong>Atomicity </strong>describes an all or nothing principle. Either all operations performed within the transaction get executed or none of them. That means if you commit the transaction successfully, you can be sure that all operations got performed. It also enables you to abort a transaction and roll back all operations if an error occurs.</li><li>The <strong>consistency </strong>characteristic ensures that your transaction takes a system from one consistent state to another consistent state. That means that either all operations were rolled back and the data was set back to the state you started with or the changed data passed all consistency checks. In a relational database, that means that the modified data needs to pass all constraint checks, like foreign key or unique constraints, defined in your database.</li><li><strong>Isolation</strong> means that changes that you perform within a transaction are not visible to any other transactions until you commit them successfully.</li><li><strong>Durability</strong> ensures that your committed changes get persisted.</li></ul>



<p>As you can see, a transaction that ensures these characteristics makes it very easy to keep your data valid and consistent.</p>



<p>Relational databases support ACID transactions, and the JDBC specification enables you to control them. Spring provides annotations and different transaction managers to integrate transaction management into their platform and to make it easier to use. But in the end, it all boils down to the features provided by these lower-level APIs.</p>



<h3><span id="Using_transactions_with_JDBC">Using transactions with JDBC</span></h3>



<p>There are 3 main operations you can do via the java.sql.Connection interface to control an ACID transaction on your database. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">try (Connection con = dataSource.getConnection()) {
    con.setAutoCommit(false);

    // do something ...
	
    con.commit();
} catch (SQLException e) {
    con.rollback();
}</pre>



<p>You can:</p>



<ul><li>Start a transaction by getting a Connection and deactivating auto-commit. This gives you control over the database transaction. Otherwise, you would automatically execute each SQL statement within a separate transaction. </li><li>Commit a transaction by calling the commit() method on the Connection interface. This tells your database to perform all required consistency checks and persist the changes permanently.</li><li>Rollback all operations performed during the transaction by calling the rollback() method on the Connection interface. You usually perform this operation if an SQL statement failed or if you detected an error in your business logic.</li></ul>



<p>As you can see, conceptually, controlling a database transaction isn&#8217;t too complex. But implementing these operations consistently in a huge application, it&#8217;s a lot harder than it might seem. That&#8217;s where Spring&#8217;s transaction management comes into play.</p>



<h2><span id="Managing_Transactions_with_Spring">Managing Transactions with Spring</span></h2>



<p>Spring provides all the boilerplate code that&#8217;s required to start, commit, or rollback a transaction. It also integrates with Hibernate&#8217;s and JPA&#8217;s transaction handling. If you&#8217;re using Spring Boot, this reduces your effort to a @Transactional annotation on each interface, method, or class that shall be executed within a transactional context.</p>



<p>If you&#8217;re using Spring without Spring Boot, you need to activate the transaction management by annotating your application class with @EnableTransactionManagement.</p>



<p>Here you can see a simple example of a service with a transactional method.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Service 
public class AuthorService {     
	private AuthorRepository authorRepository;     
	
	public AuthorService(AuthorRepository authorRepository) {         		
		this.authorRepository = authorRepository;     
	}     
	
	@Transactional     
	public void updateAuthorNameTransaction() {         
		Author author = authorRepository.findById(1L).get(); 
        author.setName(&quot;new name&quot;);     
	} 
}</pre>



<p>The @Transactional annotation tells Spring that a transaction is required to execute this method. When you inject the AuthorService somewhere, Spring generates a proxy object that wraps the AuthorService object and provides the required code to manage the transaction. </p>



<p>By default, that proxy starts a transaction before your request enters the first method that&#8217;s annotated with @Transactional. After that method got executed, the proxy either commits the transaction or rolls it back if a RuntimeException or Error occurred. Everything that happens in between, including all method calls, gets executed within the context of that transaction.</p>



<p>The @Transactional annotation supports a set of attributes that you can use to customize the behavior. The most important ones are propagation,  readOnly, rollbackFor, and noRollbackFor. Let&#8217;s take a closer look at each of them.</p>



<h3><span id="Defining_Transaction_Propagation">Defining Transaction Propagation</span></h3>



<p>Spring&#8217;s Propagation enum defines 7 values that you can provide to the propagation attribute of the @Transactional annotation. </p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Service
public class AuthorService {

    private AuthorRepository authorRepository;

    public AuthorService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateAuthorNameTransaction() {
        Author author = authorRepository.findById(1L).get();
        author.setName(&quot;new name&quot;);
    }
}</pre>



<p>They enable you to control the handling of existing and creation of new transactions. You can choose between:</p>



<ul><li>REQUIRED to tell Spring to either join an active transaction or to start a new one if the method gets called without a transaction. This is the default behavior.</li><li>SUPPORTS to join an activate transaction if one exists. If the method gets called without an active transaction, this method will be executed without a transactional context.</li><li>MANDATORY to join an activate transaction if one exists or to throw an Exception if the method gets called without an active transaction.</li><li>NEVER to throw an Exception if the method gets called in the context of an active transaction.</li><li>NOT_SUPPORTED to suspend an active transaction and to execute the method without any transactional context.</li><li>REQUIRES_NEW to always start a new transaction for this method. If the method gets called with an active transaction, that transaction gets suspended until this method got executed.</li><li>NESTED to start a new transaction if the method gets called without an active transaction. If it gets called with an active transaction, Spring sets a savepoint and rolls back to that savepoint if an Exception occurs.</li></ul>



<h3><span id="Using_Read-Only_Transactions">Using Read-Only Transactions</span></h3>



<p>If you want to implement a read-only operation, I recommend using a <a href="https://thorben-janssen.com/dto-projections/">DTO projection</a>. It enables you to only read the data you actually need for your business code and <a href="https://thorben-janssen.com/entities-dtos-use-projection/">provides a much better performance</a>.</p>



<p>But if you decide to use an entity projection anyways, you should at least mark your transaction as read-only. Since Spring 5.1, this sets Hibernate&#8217;s <a href="https://thorben-janssen.com/11-jpa-hibernate-query-hints-every-developer-know/">query hint</a> org.hibernate.readOnly and avoids dirty checks on all retrieved entities.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Service
public class AuthorService {

    private AuthorRepository authorRepository;

    public AuthorService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    @Transactional(readOnly = true)
    public Author getAuthor() {
        return authorRepository.findById(1L).get();
    }
}</pre>



<h3><span id="Handling_Exceptions">Handling Exceptions</span></h3>



<p>I explained earlier, that the Spring proxy automatically rolls back your transaction if a RuntimeException or Error occurred. You can customize that behavior using the rollbackFor and noRollbackFor attributes of the @Transactional annotation. </p>



<p>As you might guess from its name, the rollbackFor attribute enables you to provide an array of Exception classes for which the transaction shall be rolled back. And the noRollbackFor attribute accepts an array of Exception classes that shall not cause a rollback of the transaction.</p>



<p>In the following example, I want to roll back the transaction for all subclasses of the Exception class except the EntityNotFoundException.</p>



<pre class="wp-block-preformatted brush: java; gutter: true">@Service
public class AuthorService {

    private AuthorRepository authorRepository;

    public AuthorService(AuthorRepository authorRepository) {
        this.authorRepository = authorRepository;
    }

    @Transactional
		(rollbackFor = Exception.class, 
		 noRollbackFor = EntityNotFoundException.class)
    public void updateAuthorName() {
        Author author = authorRepository.findById(1L).get();
        author.setName(&quot;new name&quot;);
    }
}</pre>



<h2><span id="Conclusion">Conclusion</span></h2>



<p>Spring Boot and Spring Data JPA provide an easy to use transaction handling. You only need to annotate your interface, class, or method with Spring&#8217;s @Transactional annotation. Spring then wraps your service in a generated proxy that joins an active transaction or starts a new one and commits or rolls the transaction back after your method got executed.</p>



<p>You can customize the default behavior using the propagation, readOnly, rollbackFor, and noRollbackFor attributes:</p>



<ul><li>The propagation attribute gives you control over the handling of existing and the creation of new transactions. If your method gets called within the context of an activate transaction, you can, for example, decide if your method shall join that transaction, create a new one, or fail.</li><li>You can use the readOnly attribute to improve the performance of read-only operations.</li><li>The rollbackFor and noRollbackFor attributes enable you to define which Exception classes will cause a rollback of your transaction and which can be handled by your business logic.</li></ul></div><div class="col-lg-2 col-md-2 invisible"></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script></body></html>